    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Симуляция устройства делительной головки</title>
        <script
        type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/brython@3.10.6/brython.min.js"
      ></script>
      <script
        type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/brython@3.10.6/brython_stdlib.js"
      ></script>

    <style>
    html {
        line-height: 1.4;
        font-weight: normal;
        font-size: 1rem;
        font-family: "Source Sans Pro", Arial, sans-serif;
        color: rgb(41, 41, 41);
    }
    body {
        margin: 0;
        padding: 0;
    }
    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 20px;
        margin-bottom: 30px;
        background-color: #c3cfe267; 
        border: 1px solid #c3cfe2;
    }
    header .title {
        text-transform: lowercase;
    }
    header .about {
        font-weight: normal;
        display: flex;
        flex-direction: column;
        flex-wrap: wrap;
    }
    .about a {
        font-size: 0.9em;
        font-weight: bold;
    }
    .svg-obj .lcontent {
        margin: 20px 40px;
        padding: 0 10px;
        width: 500px;
        height: 450px;
        border: 1px solid rgba(72, 114, 230, 0.493);
        float: left;
    }
    .svg-obj .rcontent {
        margin: 20px 0;
        padding: 20 10px;
        width: 650px;
        height: 450px;
        border: 1px solid rgba(72, 114, 230, 0.493);
        float: left; 
    }
    .cntcontent {
            width: 10px;            
            float: left;
            margin: 20px 10px;
        }
    .bcontent {
        clear: both;
        width: 97%;
        padding: 20px 20px;
        border: 1px solid rgba(52, 216, 65, 0.493);
    }
    .start{
        box-shadow:inset 0px 1px 0px 0px #9acc85;
        background:linear-gradient(to bottom, #74ad5a 5%, #68a54b 100%);
        background-color:#74ad5a;
        border-radius: 5px;
        border:1px solid #3b6e22;
        display:inline-block;
        cursor:pointer;
        color:#ffffff;
        padding:10px 16px;
        font-size: 1em;
        text-decoration:none;
        }
    .start:hover {
        background:linear-gradient(to bottom, #68a54b 5%, #74ad5a 100%);
        background-color:#68a54b;
        }
    .start:active {
        position:relative;
        top:1px;
        }
    .stop {
        box-shadow:inset 0px 1px 0px 0px #cf866c;
        background:linear-gradient(to bottom, #d0451b 5%, #bc3315 100%);
        background-color:#d0451b;
        border-radius:5px;
        border:1px solid #942911;
        display:inline-block;
        cursor:pointer;
        color:#ffffff;
        font-size: 1em;
        padding:10px 16px;
        text-decoration:none;
        text-shadow:0px 1px 0px #854629;
        }
    .stop:hover {
        background:linear-gradient(to bottom, #bc3315 5%, #d0451b 100%);
        background-color:#bc3315;
        }
    .stop:active {
        position:relative;
        top:1px;
        }
    button {
        box-shadow:inset 0px 1px 0px 0px #a6827e;
        background:linear-gradient(to bottom, #7d5d3b 5%, #634b30 100%);
        background-color:#7d5d3b;
        border-radius:5px;
        border:1px solid #54381e;
        display:inline-block;
        cursor:pointer;
        color:#ffffff;
        font-size:1em;
        padding:10px 16px;
        text-decoration:none;
        }
    button:hover {
        background:linear-gradient(to bottom, #634b30 5%, #7d5d3b 100%);
        background-color:#634b30;
        }
    button:active {
        position:relative;
        top:1px;
        } 
    .suply button {
        margin: 0 10px;
    } 
    
    </style>
    </head>

    <body onload="brython(1)"> 
    <header>
        <h1 class="title">Модель делительной головки для станка</h1>
        <div class="about"> 
            <svg height="42" aria-hidden="true" viewBox="0 0 16 16" version="1.1" width="42"        data-view-component="true" class="octicon octicon-mark-github v-align-middle">
            <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
        <a href="https://github.com/slawa-popow/headdiv_arduino">проект</a>
       </div>
    </header>
    <section class="svg-obj">
    <div class="lcontent">
        <svg width="450" height="350" viewBox="0 0 250 150" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient gradientUnits="userSpaceOnUse" x1="171.645" y1="201.89" x2="171.645" y2="210.213" id="gradient-0" gradientTransform="matrix(0.510622, 0, 0, 1.081309, 128.372154, -157.130177)">
                <stop offset="0" style="stop-color: rgb(214, 214, 214);"></stop>
                <stop offset="0.416" style="stop-color: rgb(168, 168, 168);"></stop>
                <stop offset="0.518" style="stop-color: rgb(166, 166, 166);"></stop>
                <stop offset="1" style="stop-color: rgb(214, 214, 214);"></stop>
              </linearGradient>
            </defs>
            <g id="servo">
            <rect x="132.3" y="41.918" width="81.218" height="48" style="stroke: rgb(0, 0, 0); stroke-width: 0px; fill: rgb(122, 122, 122);"></rect>
            <rect x="132.645" y="42.175" width="6" height="48" style="fill: rgb(240, 240, 240); stroke: rgba(0, 0, 0, 0.17);"></rect>
            <rect x="207.123" y="42.175" width="6" height="47.304" style="fill: rgb(240, 240, 240); stroke: rgba(0, 0, 0, 0.17);"></rect>
            <rect x="213.517" y="61.175" width="5" height="9" style="stroke: rgb(0, 0, 0); stroke-width: 0px; fill: url(#gradient-0);"></rect>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="139.042" y1="80.641" x2="206.822" y2="80.641"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.744" y1="74.099" x2="206.524" y2="74.099"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.596" y1="66.814" x2="206.376" y2="66.814"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.744" y1="59.528" x2="206.524" y2="59.528"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.744" y1="52.54" x2="206.524" y2="52.54"></line>
            <rect style="fill: rgb(216, 216, 216); stroke: rgb(197, 188, 188);" x="31.483" y="36.745" width="100.666" height="90.741" rx="5" ry="5"></rect>
            <path id="val" transform-origin="82.2 81.1" style="paint-order: fill; stroke: rgb(80, 75, 75); fill: rgb(117, 147, 189);" d="M 82.168 70.275 C 90.464 70.275 95.65 79.257 91.501 86.442 C 87.353 93.627 76.982 93.627 72.834 86.442 C 69.826 81.233 71.665 74.57 76.918 71.641 L 78.068 76.269 L 83.295 74.868 L 82.168 70.275 Z"  ></path>
            <circle id="limb" style="fill: none; stroke-width: 8px; stroke: rgb(138, 132, 132);" cx="82" cy="81.5" r="19"></circle>
            <text style="white-space: pre; fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12.3px;" x="153.031" y="178.119" transform="matrix(0.816774, 0, 0, 0.806308, -87.585098, -112.05706)">редуктор</text>
            <text style="white-space: pre; fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12.3px;" x="153.031" y="178.119" transform="matrix(0.848315, 0, 0, 0.813387, 49.176811, -111.468437)">мотор</text>
            <rect style="stroke: rgb(0, 0, 0); fill: none;" x="39.326" y="43.84" width="84.525" height="75.133" rx="5" ry="5"></rect>
         </g> 
        </svg>
    </div>
    <!--  -->
    <div class="cntcontent"></div>
    <!--  -->
    <div class="rcontent">
        <svg width="600" height="400" viewBox="0 0 400 200" 
        xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com">
            <defs>
              <radialGradient gradientUnits="userSpaceOnUse" cx="553.185" cy="313.038" 
              r="104.465" id="gradient-10" 
              gradientTransform="matrix(0.805315, -0.586333, 0.670928, 0.901363, -102.328976, 355.227791)">
                <stop offset="0" style="stop-color: rgb(225, 176, 96);"></stop>
                <stop offset="1" style="stop-color: rgb(133, 89, 35);"></stop>
              </radialGradient>
            </defs>
            <g transform="matrix(1, 0, 0, 1, 0, 0.269827)">
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="55.65" y1="132.237" x2="55.65" y2="147.357"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="65.287" y1="133.651" x2="65.287" y2="147.091"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="77.401" y1="131.795" x2="77.401" y2="146.915"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="87.569" y1="133.563" x2="87.569" y2="146.915"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="96.499" y1="133.829" x2="96.499" y2="146.65"></line>
              <g transform="matrix(1, 0, 0, 1, -1.069491, -0.763923)">
                <rect x="51.033" y="110.69" width="53.04" height="23.256" style="stroke: rgb(0, 0, 0); vector-effect: non-scaling-stroke; fill: rgba(82, 180, 49, 0.66);"></rect>
                <g transform="matrix(0.62624, 0.021869, 0.021869, -0.62624, 15.6054, 205.660828)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" d="M 126.564 126.466 C 127.81 125.869 129.621 122.583 128.694 120.978 C 127.767 119.373 125.45 119.372 124.523 120.978 C 123.842 122.157 125.005 125.863 126.206 126.504"></path>
                  <line style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" x1="126.42" y1="126.103" x2="126.235" y2="133.681"></line>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="1.259"></circle>
                </g>
                <g transform="matrix(0.62624, 0.021869, 0.021869, -0.62624, -3.451744, 206.020294)" >
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" d="M 126.564 126.466 C 127.81 125.869 129.621 122.583 128.694 120.978 C 127.767 119.373 125.45 119.372 124.523 120.978 C 123.842 122.157 125.005 125.863 126.206 126.504"></path>
                  <line style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" x1="126.42" y1="126.103" x2="126.235" y2="133.681"></line>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="1.259"></circle>
                </g>
                <g transform="matrix(0.890533, 0, 0, 0.890533, -46.515045, 15.501225)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 126.655 128.324 C 127.436 128.698 128.57 130.757 127.99 131.763 C 127.409 132.768 125.957 132.769 125.376 131.763 C 124.949 131.024 125.678 128.702 126.43 128.3" transform="matrix(0.999391, 0.0349, -0.0349, 0.999391, 4.628443, -4.34236)"></path>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="0.789" transform="matrix(0.999391, 0.0349, 0.0349, -0.999391, -8.816491, 247.268634)"></circle>
                  <path style="fill: none; stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 121.95 117.579 L 121.9 121.712 L 126.679 123.798 L 126.629 128.548"></path>
                </g>
                <g transform="matrix(1, 0, 0, 1, -0.152784, -0.305569)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 88.691 133.765 C 89.386 133.432 90.396 131.598 89.88 130.702 C 89.362 129.807 88.069 129.806 87.552 130.702 C 87.172 131.36 87.821 133.428 88.491 133.786" transform="matrix(-0.999391, 0.0349, -0.0349, -0.999391, 182.010373, 260.639327)"></path>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="0.703" transform="matrix(-0.999391, 0.0349, -0.0349, -0.999391, 223.73009, 250.266071)"></circle>
                  <path style="fill: none; stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 88.793 130.251 L 88.748 126.571 L 93.004 124.713 L 92.96 120.483" transform="matrix(-1, 0, 0, -1, 181.751999, 250.734009)"></path>
                </g>
                <g transform="matrix(0.62624, 0.021869, 0.021869, -0.62624, -25.26741, 206.068115)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" d="M 126.564 126.466 C 127.81 125.869 129.621 122.583 128.694 120.978 C 127.767 119.373 125.45 119.372 124.523 120.978 C 123.842 122.157 125.005 125.863 126.206 126.504"></path>
                  <line style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" x1="126.42" y1="126.103" x2="126.235" y2="133.681"></line>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="1.259"></circle>
                </g>
              </g>
            </g>
            <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12px; white-space: pre;" x="16.636" y="17.109">энкодер</text>
           <g id="lcd">
            <rect  style="fill: rgb(158, 182, 121); stroke-width: 3px; stroke: rgb(88, 85, 75);" x="190" y="33" width="180" height="125" rx="3" ry="3" ></rect>
            </g>
            <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12px; white-space: pre;" x="190.548" y="20.798">LCD</text>
            <g id="encoder" transform-origin="77 73" transform="matrix(0.999999, 0, 0, 0.999999, 0.000041, 0.000206)" >
              <g transform="matrix(1, 0, 0.000001, 0.989012, -0.407998, -16.634939)">
                <path id="encoder-svg" style="stroke: rgb(0, 0, 0); fill: url(#gradient-10);" transform="matrix(0.430767, 0, 0, 0.435553, -160.723328, -45.253071)" d="M 548.60465399 211.683 L 557.76534601 211.683 L 562.163755299 208.573152069 A 104.85 104.85 0 0 1 571.549680557 209.808832571 L 574.993329812 213.951107096 L 583.841878821 216.322068657 L 588.895303819 214.456578317 A 104.85 104.85 0 0 1 597.641593782 218.07941024 L 599.895803997 222.971822194 L 607.829196003 227.552168204 L 613.193254149 227.058165539 A 104.85 104.85 0 0 1 620.703863609 232.821258874 L 621.615014083 238.130398469 L 628.092601531 244.607985917 L 633.401741126 245.519136391 A 104.85 104.85 0 0 1 639.164834461 253.029745851 L 638.670831796 258.393803997 L 643.251177806 266.327196003 L 648.14358976 268.581406218 A 104.85 104.85 0 0 1 651.766421683 277.327696181 L 649.900931343 282.381121179 L 652.271892904 291.229670188 L 656.414167429 294.673319443 A 104.85 104.85 0 0 1 657.649847931 304.059244701 L 654.54 308.45765399 L 654.54 317.61834601 L 657.649847931 322.016755299 A 104.85 104.85 0 0 1 656.414167429 331.402680557 L 652.271892904 334.846329812 L 649.900931343 343.694878821 L 651.766421683 348.748303819 A 104.85 104.85 0 0 1 648.14358976 357.494593782 L 643.251177806 359.748803997 L 638.670831796 367.682196003 L 639.164834461 373.046254149 A 104.85 104.85 0 0 1 633.401741126 380.556863609 L 628.092601531 381.468014083 L 621.615014083 387.945601531 L 620.703863609 393.254741126 A 104.85 104.85 0 0 1 613.193254149 399.017834461 L 607.829196003 398.523831796 L 599.895803997 403.104177806 L 597.641593782 407.99658976 A 104.85 104.85 0 0 1 588.895303819 411.619421683 L 583.841878821 409.753931343 L 574.993329812 412.124892904 L 571.549680557 416.267167429 A 104.85 104.85 0 0 1 562.163755299 417.502847931 L 557.76534601 414.393 L 548.60465399 414.393 L 544.206244701 417.502847931 A 104.85 104.85 0 0 1 534.820319443 416.267167429 L 531.376670188 412.124892904 L 522.528121179 409.753931343 L 517.474696181 411.619421683 A 104.85 104.85 0 0 1 508.728406218 407.99658976 L 506.474196003 403.104177806 L 498.540803997 398.523831796 L 493.176745851 399.017834461 A 104.85 104.85 0 0 1 485.666136391 393.254741126 L 484.754985917 387.945601531 L 478.277398469 381.468014083 L 472.968258874 380.556863609 A 104.85 104.85 0 0 1 467.205165539 373.046254149 L 467.699168204 367.682196003 L 463.118822194 359.748803997 L 458.22641024 357.494593782 A 104.85 104.85 0 0 1 454.603578317 348.748303819 L 456.469068657 343.694878821 L 454.098107096 334.846329812 L 449.955832571 331.402680557 A 104.85 104.85 0 0 1 448.720152069 322.016755299 L 451.83 317.61834601 L 451.83 308.45765399 L 448.720152069 304.059244701 A 104.85 104.85 0 0 1 449.955832571 294.673319443 L 454.098107096 291.229670188 L 456.469068657 282.381121179 L 454.603578317 277.327696181 A 104.85 104.85 0 0 1 458.22641024 268.581406218 L 463.118822194 266.327196003 L 467.699168204 258.393803997 L 467.205165539 253.029745851 A 104.85 104.85 0 0 1 472.968258874 245.519136391 L 478.277398469 244.607985917 L 484.754985917 238.130398469 L 485.666136391 232.821258874 A 104.85 104.85 0 0 1 493.176745851 227.058165539 L 498.540803997 227.552168204 L 506.474196003 222.971822194 L 508.728406218 218.07941024 A 104.85 104.85 0 0 1 517.474696181 214.456578317 L 522.528121179 216.322068657 L 531.376670188 213.951107096 L 534.820319443 209.808832571 A 104.85 104.85 0 0 1 544.206244701 208.573152069 Z M 553.185 313.038 A 0 0 0 0 0 553.185 313.038 A 0 0 0 0 0 553.185 313.038" bx:shape="cog 553.185 313.038 0 104.85 101.355 0.31 24 1@c59c0b7b"></path>
                <circle style="fill: none; vector-effect: non-scaling-stroke; stroke: rgb(135, 96, 17);" cx="77.759" cy="90.749" r="32.317"></circle>
              </g>
              <line style="fill: none; stroke: rgb(188, 183, 171);" x1="77.678" y1="73.323" x2="93.689" y2="32.659"></line>
            </g>
          </svg>
          <div class="suply">
            <button class="start" id="power-on">включить</button>
            <button class="stop" id="power-off">отключить</button>
          </div>
    </div>
    <!--  -->
    <div class="bcontent">
    

    </div>
    </section>   

    
    <script type="text/python">

    from browser import document, window, html, bind, timer
    from typing import Any, Callable
    import time



    # ----------------------------------------- ID графических штук ----------------------------------------------------------------------------------------
    #
    # id мотор-редуктора:   ["val"] - вал (с синим оттенком на редукторе) со шнопочным пазом
    #                       ["limb"] - меняет цвет на зеленый когда мотор работает. На рисунке - похож на сальник вокруг вала
    # id енкодера:          ["encoder"] - <g> колесо енкодера со всеми графическими дополнениями. Ручка, которую надо крутить для настройки.
    #                       ["encoder-svg"] - контур path фигуры колеса енкодера. Использую для перекрашивая контура при наведении мышкой
    # id lcd дисплея:       ["lcd"] - прямоугольник похожий на дисплей. Группа <g>
    #                               xk, yk - координаты строк. где k номер строки:
    #                                   (x1=195, y1=50), (x2=195, y2=64), (x3=195, y2=78), (x4=195, y4=92),
    #                                   (x5=195, y5=106), (x6=195, y6=120), (x7=195, y7=134), (x8=195, y8=148)
    #                       как видно координаты x начала строки - 195px относительно границы viewBox, а
    #                       y(высота) от начала (1 строчки) 50px и через каждые 14px (размер шрифта + 2px для разделения строк)
    #                       до последней 8 строчки 148px. Длинна строки - 23 символа. Почему так? Хрен его знает. Так нарисовал. Для демонстрации пойдет.
    #                 
    # id кнопок:            ["power-on"] - зеленая. Включить питание.
    #                       ["power-off"] - красная. Откл. питание. Стоп
    #                       ["encoder"] - кнопка колесика мыши. Работает с событием "mousedown". Номер кнопки = 2
    #
    #
    #
    # ---------------------------------------------------------------------------------------------------------------------------------------------------------


    class Component:
        """Базовый класс всех компонентов.
           Задает во всех объектaх модулей объект чипа ATMega. [mega = None]"""

        def __init__(self) -> None:
            self._mega = None

        @property
        def mega(self):
            return self._mega

        @mega.setter
        def mega(self, obj) -> None:
            self._mega = obj
      



    class Display(Component):
        '''Родительский класс дисплея. Делает закулисную грязную работу. Будет по id svg объекта
           вычислять атрибуты: число строк, длинна строки, координаты начала строки
           размеры дисплея... короче чтобы не париться, а нарисованный/перемещенный 
           дисплейчик без страданий можно было юзать.'''

        
        def __init__(self, id_svg: str, size_char: int, line_height=2) -> None:
            super().__init__()

                # объект svg <g> дисплея
            self._id_lcd = document[id_svg]

                # размер шрифта (высота символа) в пикселях. т-е число int это размер в пикселях.
            self._size_char = size_char

                # межстрочный интервал px
            self._line_height = line_height
            
                # cоздаю атрибуты из полученных данных от getBBox():
                # self._x, self._y -- координаты фигуры 
                # self._width, self._height -- ширина, высота фигуры

            for name_attr, value_attr in dict(self._id_lcd.getBBox()).items():
                super().__setattr__("_" + name_attr, value_attr)
            
                # координаты первой строки
            self._first_line_coord: tuple = self.__get_coords_first_line()

                # макс. число строк с учетом высоты символа + межстрочного интевала
            self._max_lines: int = self._height // (self._size_char+self._line_height)

                # словарь [№строки : координата Y]
            self._lines_coords: dict = self.__get_lines_coords()
                
                # словарь обЪектов строк. Строки добавляются в write()
            self._svg_lines: dict = dict()

                # макс. длинна строки (символов). 4 - от балды взято (на самом деле с 4 расчет более-менее правильный)
            self._max_len: int = (self._width + self._first_line_coord[0]) // (self._size_char + 4)


        # ---------------------------------------------------------------------------------------------------

        def __get_lines_coords(self) -> dict:
            """Возвращает словарь с вычисленными координатами (X, Y) начала
               всех влезаемых в дисплей строк"""

            x, y = self._first_line_coord
            d: dict = dict()
            for i in range(1, self._max_lines+1):
                d[i] = (x, y)
                y += self._size_char + self._line_height
            return d
        
        
        def write(self, wtext: str, line: int) -> None:
            """Записать текст по номеру строки line.
               Создаются строки как svg объекты."""

            try:
                if (1 <= line <= self._max_lines):
                    crdX, crdY = self._lines_coords[line]

                        # если такой номер строки существует, то чистим ее и создаем новую.
                    if line in self._svg_lines:
                        self.clean(line)

                    svgNS = "http://www.w3.org/2000/svg"
                    newline = document.createElementNS(svgNS, "text")
                    newline.setAttributeNS(None, "id", f"{line}-line")
                    newline.setAttributeNS(None, "style", f"fill: rgb(51, 51, 51); font-family: monospace; font-size: {self._size_char}px;")
                    newline.setAttributeNS(None, "x", f"{crdX}")
                    newline.setAttributeNS(None, "y", f"{crdY}")

                        # если длинна строки больше максимально допустимой, то записываю только часть строки == макс. длинны
                    newline.textContent = wtext if (0 < len(wtext) <= self._max_len) else wtext[: self._max_len]       
                    
                    self._id_lcd.appendChild(newline)
                    self._svg_lines[line] = newline
                else:
                    raise ValueError("Не корректный номер строки. Ошибка.")
            except ValueError as ve:
                print(ve)
            except TypeError as te:
                print("Ошибка, не числовое значение line", te)



        def clean(self, line=None) -> None:
            """Очистка экрана. если вызвать метод без параметров
               то чистится все табло. """

            if line is None:
                if self._svg_lines:
                    for k, v in self._svg_lines.items():
                        self._id_lcd.removeChild(v)
                    self._svg_lines.clear()
            else:
                self._id_lcd.removeChild(self._svg_lines[line])



        def __get_coords_first_line(self) -> tuple:
            """Возвращает координаты первой строки с 
               учетом высоты символа  и межстрочного интевала"""

            return (self._x+5, self._y+self._size_char+self._line_height)

        # ---------------------------------------------------------------------------------------------------------

    class Lcd(Display):
        """Дисплей"""

        def __init__(self, id_svg: str, size_char: int) -> None:
            """2 параметра: айди грфического объекта группы <g> - id_svg; 
                            размер шрифта - size_char"""

            super().__init__(id_svg, size_char)
            self.on_power()

            
        @property
        def id(self):
            """объект svg дисплея. Возвращает объект прямоугольника в группе <g id="lcd">"""
            return self._id_lcd.firstElementChild

        @id.setter
        def id(self, value: Any):
            """Не изменяемый"""
            pass


        def on_power(self) -> None:
            """Включить питание. Цвет дисплея светло зелено-серый"""

            self.id.style["fill"] = f"rgb(203, 240, 143)"



        def off_power(self) -> None:
            """Отключить питание. Стереть всё."""

            self.id.style["fill"] = f"rgb(158, 182, 121)"
            self.clean()



        # --------------------------------------------------------------------------------------------------------------

    class Encoder(Component):
        """Ручной енкодер"""

        def __init__(self, id_encoder: str, id_encoder_path: str) -> None:
            """id_encoder - айди группы <g> svg объекта; id_encoder_path - айди обводки колесика (paht)"""

            super().__init__()

                # объект группы енкодера
            self._id = document[id_encoder]

                # <path>. Hужна его обводка для выделения при наведении мыши
            self._path_id = document[id_encoder_path]

                # на сколько градусов повернуть за раз енкодер 
            self._deg_step = 10
                
                # сумма поворотов
            self._total_deg = 0

                # направление вращения: 1 туда, -1 сюда
            self.around_direction: int = 1

                # Имя браузера (не понадобилось. Оставил на память для что-как-куда)
            self.navigator: list = window.navigator.userAgent.split("/")[2].split()[-1]

                # обработчики событий прокрутки колесика мыши над енкодером для браузеров Firefox и группы v8 
            self._id.bind("mousewheel", self.wheel)
                # Этот для Firefox
            self._id.bind("DOMMouseScroll", self.wheel) 

                # Обработчик события по наведении указателя мыши на енкодер
            self._id.bind("mouseover", self.select_encoder)

                # Обработчик события если убрать указатель мыши из области енкодера
            self._id.bind("mouseout", self.no_select_encoder)

                # Обработчик события при нажатия на колесико мыши на енкодер.
            self._id.bind("mousedown", self.click_wheel)


        @property
        def deg_step(self) -> int:
            """Вернуть шаг поворота"""

            return self._deg_step


        @deg_step.setter
        def deg_step(self, value: int) -> None:
            self._deg_step = value


        @property
        def total_deg(self) -> int:
            """Геттер вернет общее кол-во поворотов енкодера."""

            return self._total_deg


        @total_deg.setter
        def total_deg(self, value: int) -> None:
            self._total_deg = value
        

        def wheel(self, e) -> None:
            """wheelDelta - группа браузеров v8, detail - мозилла.
               если событие пришло от браузеров группы v8 то значение
               вернувшее wheelDelta (120) изменяем на 1 поделив его на 120. 
               detail есть в мозилле и он вернет или -1 или 1. В зависимости 
               от браузера в любом случае значение объекта события нужно сделать равным 1
               и умножить на наш шаг-градусы разовой прокрутки енкодера. Код честно спер с какого-то
               сайта про javascript."""

            delta = None
            if hasattr(e, "wheelDelta"):
                delta = e.wheelDelta / 120
                self.total_deg += delta * (-self.deg_step)
    
            elif hasattr(e, "detail"):
                delta = e.detail / 3
                self.total_deg += delta * (-self.deg_step)
                
            if delta:
                    # сохранить знак направления вращения, запретить прокрутку над svg объектом
                self.around_direction = 1 if delta > 0 else -1
                e.preventDefault()

                if abs(self.total_deg) >= 360:
                    self.total_deg = 0
            self._id.attrs["transform"] = f"rotate({self.total_deg})"  

            self.mega.wheel_method() 
            
            

        def select_encoder(self, e) -> None:
            """Сменить цвет обводки на красный при наведении указателя
               мыши на енкодер."""
            document.querySelector("body").style["cursor"] = "move"
            self._path_id.style = "stroke: red; stroke-width: 4px; fill: url(#gradient-10)"



        def no_select_encoder(self, e) -> None:
            """Вернуть черный оттенок если убрать указатель мыши
               из области фигуры енкодера."""
            document.querySelector("body").style["cursor"] = "default"
            self._path_id.style = "stroke: rgb(0, 0, 0); fill: url(#gradient-10)"



        def click_wheel(self, e) -> None:
            """При нажатии колесика мыши меняется масштаб фигуры
                енкодера, и через короткое время вызывается встроенная
                ф-ция, которая изменяет масштаб в нормальное значение."""

            def reset():
                self._id.attrs["transform"] = f"scale(1), rotate({self.total_deg})"

            if e.which == 2:
                self._id.attrs["transform"] = f"scale(0.98), rotate({self.total_deg})"
                timer.set_timeout(reset, 150)
                
                self.mega.push_wheel_method() 
                

    # -----------------------------------------------------------------------------------------------------------

    class Motor(Component):
        """Мотор-редуктор"""

        def __init__(self, id_val: str, id_limb: str) -> None:
            super().__init__()

                # объект вала
            self._id = document[id_val]

                # оъект круглой толстой штуки вогруг синего вала
            self._limb = document[id_limb]

                # на сколько градусов провернут вал
            self._total_d: int = 0

               


        @property
        def id(self):
            return self._id

        @id.setter
        def id(self, value) -> None:
            pass


        @property
        def limb(self):
            return self._limb

        @limb.setter
        def limb(self, value) -> None:
            pass

        
        @property
        def degstep(self) -> int:
            return self._total_d

        @degstep.setter
        def degstep(self, value) -> None:
            
            self._total_d += float(value)
            if abs(self._total_d) >= 360:
                self._total_d = 0
            print(value, self._total_d)
            self.id.attrs["transform"] = f"rotate({self._total_d})"

    # -------------------------------------------------------------------------------------------------------------
    
    def inject(method_setter: Callable) -> Callable:
        """Декоратор для сеттеров. Внедряет объект ATMega в объект каждой компоненты
            до присваивания соотв. атрибута экземпляра ATMega. """

        def wrapper(self, obj) -> None:
            obj.mega = self
            method_setter(self, obj)
            
        return wrapper            

         


    class ATMega:
        """Ардуина. Чип: 8-bit Atmel ATmega2560.
           Модель классов напоминает паттерн 'Посредник', 
           только без интерфейса. Этот в роли посредника."""

        def __init__(self, lcd: Lcd, encoder: Encoder, motor: Motor):
            self.lcd = lcd
            self.encoder = encoder
            self.motor = motor

                # хранит позицию выделенного пункта меню
            self.nav = 1


                # сохраняет ссылку на метод события нажатия колесика перед экзекуцией
            self.stackpush = None

                # хранит строки дисплея текущего состояния
            self.map_display: list = list()
                
                # состояние. начальное состояние = 'BEGIN'
            self._state = 6

            self._substate = 0

                # счетчик таймера. Для мигания выбранного поля ввода.
            self.blink: int = 0
                
                # таймер
            self.timer = time.time()

                # метод вызываемый при прокрутки колеса мыши
            self.wheel_method: Callable = self.round_wheel

                # метод вызываемый при нажатии на колесо мыши
            self.push_wheel_method: Callable = self.button_wheel
            
                # передаточное число
            self.delta_reductor: float = 1.0

                # скорость в режиме разметки
            self.vauto: float = 0.5


                # константы макро состояний
            self.enum_state: dict = {
                None: "END", 1: "EQUALLY", 2: "SETTING", 3: "ARRAY", 4: "PREPARE", 5: "RUN_AUTO", 6: "BEGIN"
            }
                # дисплеи состояний, пункты меню, замещающие ссылки методов на события вращения и нажатия колеса мыши 
            self.displays: dict = { 
                "BEGIN":{"nav":{1: ["да", self.st_mtd_yes], 2: ["настр.", self.st_mtd_settings], 3: ["нет", self.st_mtd_no]},
                         "field": dict(),
                         "text": {2: f"{'\u00A0'*6}"+"равномерная", 3: f"{'\u00A0'*7}"+"разметка"},
                         "navigate": True
                         
                },
                "SETTING":{"nav":{1: ["да", self.st_mtd_sett_yes],  2: ["нет", self.st_mtd_sett_no]},
                            "field":{3: [f"передат. число:", self.set_dreductor, self.delta_reductor], 4: [f"скорость авто:", self.set_vauto, self.vauto]},
                            "text": {1: f"{'\u00A0'*2}"+"глобальные"+f"{'\u00A0'}"+"настройки"},
                            "navigate": True
                }
            }

        # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 

        def run(self) -> None:
            """Пуск машины состояний."""

            s = self.enum_state.get(self.state)
            if not s:
                self.state = 6
                self.substate = 0

            dsp = self.displays[s]

                # для моргания значения пункта поля ввода в меню настроек
            if (time.time() - self.timer) >= 0.3:
                self.blink += 1
                self.timer = time.time()
                if self.blink >= 255:
                    self.blink = 0
           
            
            
                # очистка и наполнение при каждом вызове атрибута-словаря пунктами меню 
                # (строка навигации и если есть поля ввода) текущего дисплея состояния.
            self.map_display.clear()
            self.map_display.extend([dsp["nav"], dsp["field"]])

                # проверка что мы сейчас не редактируем параметры настроек. Только для колесика мыши.
            if dsp["navigate"]:
                    # замещение метода события вращения колеса
                self.wheel_method = self.st_mtd_wheel

                # замещение метода события нажатия колесика мыши по пунктам меню
            self.push_wheel_method = self.get_deploy_map_display()[self.nav][1]
            

            # --------------------------------> BEGIN state
            if s == "BEGIN":
                
                    # текст на табло
                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                    # получить строку навигации и полей ввода (если есть)
                navigate, field_sett = self.get_nav(s) 
               
                    # вывести меню на экран
                self.lcd.write(navigate, 8) 


            # --------------------------------> SETTING state   
            elif s == "SETTING":
                

                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                navigate, field_sett = self.get_nav(s)
                
                    # вывести меню на экран
                self.lcd.write(navigate, 8) 
                
                    # вывод полей ввода и значений на экран
                for i, line in enumerate(field_sett):
                    self.lcd.write(line, i+3)

                # void loop()
            window.setTimeout(self.run)


        def apply(self) -> None:
            self.stacknav = 1
            
            self.displays[self.enum_state.get(self.state)]["navigate"] = True
            self.displays[self.enum_state.get(self.state)]["field"][self.nav][1] = self.stackpush
            self.stackpush = None



        def count_field(self) -> None:
            
            self.displays[self.enum_state.get(self.state)]["field"][self.nav][2] += (self.encoder.around_direction / 2.0)
            


        def st_mtd_yes(self) -> None:
            """пункт меню ДА-главный экран. Событие по нажатии"""

            self.lcd.write("выбор: да", 5)


        def st_mtd_settings(self) -> None:
            """пункт меню НАСТР.-главный экран. Событие по нажатии"""

            self.state = 2
            self.lcd.clean()
            self.nav = 1 


        def st_mtd_no(self) -> None:
            """пункт меню НЕТ-главный экран. Событие по нажатии"""

            self.lcd.write("выбор: нет", 5)




        def st_mtd_sett_yes(self) -> None:
            """пункт меню ДА-меню настройки. Событие по нажатии"""

            self.state = 6
            self.nav = 1
            self.lcd.clean()


        def st_mtd_sett_no(self) -> None:
            """пункт меню НЕТ-меню настройки. Событие по нажатии"""

            self.state = 6
            self.nav = 1
            self.lcd.clean()



        def set_dreductor(self) -> None:
            """поле ввода ПЕРЕДАТОЧН. ЧИСЛО РЕДУКТОРА.
            экран настройки. Событие по нажатии"""
                
               
            
            
                # подменяю метод при вращении колеса мыши
            self.wheel_method = self.count_field
                # сохраняю ссылку на метод (который по умолчанию) нажатии колесика мыши 
            self.stackpush = self.displays[self.enum_state.get(self.state)]["field"][self.nav][1]
                # теперь этому полю подменяю метод по следующему нажатию
            self.displays[self.enum_state.get(self.state)]["field"][self.nav][1] = self.apply
                # запрет навигации. только больше-меньше значения параметра при вращении колеса мыши
            self.displays[self.enum_state.get(self.state)]["navigate"] = False

           
        def set_vauto(self) -> None:
            """поле ввода СКОРОСТЬ АВТО.
            экран настройки. Событие по нажатии"""

            self.st_mtd_settings()



        def st_mtd_wheel(self) -> None:
            """выделение пунктов в меню при вращении колеса мыши"""

                # в зависимости от направления вращения колеса мыши self.encoder.around_direction
                # то 1, то -1
              
            self.nav += self.encoder.around_direction
            
                # дисплей текущего состояния
            curr_display: dict = self.get_deploy_map_display()
                # количество пунктов для выделения
            len_nav = len(curr_display) 
            
                # выделение пунктов меню по кругу
            if (self.nav < 1):
                self.nav = len_nav
            elif (self.nav > len_nav):
                self.nav = 1
           
              
       
        
        def get_nav(self, current_state: str) -> tuple:
            """возвращает строку меню с помеченным пунктом. 
               При каждом вызове формирует дисплей со строками. Возвращает кортеж 
               строку меню и список строк полей ввода. Формирование экрана дисплая текущего состояния."""
           
                # словарь вида [{"nav":{1: ("да", self.st_mtd_sett_yes),  2: ("нет", self.st_mtd_sett_no)}]
            st_nav: dict = self.map_display[0]

                # словарь вида [3: (f"передат. число:", self.set_dreductor, self.delta_reductor), 4: (f"скорость авто:", self.set_vauto, self.vauto)}]
            field_nav: dict = self.map_display[1]
             
                # формирование строки меню с помеченным выбранным пунктом в зависимости от значения self.nav 
            navigate = list(map(lambda z: f"\u25b6{z[1][0]}\u25c0" if z[0] == self.nav else z[1][0], st_nav.items()))
                
                # формирование списка полей ввода с помеченным пунктом в зависимости от self.nav Работает в паре с строкой навигации
            field: list = list()
            
                # если находимся в меню настроек при редактировании, то
                # мигаем значением редактируемого поля   
            for key, val in field_nav.items():
                if key == self.nav:                    
                    if not self.displays[current_state]["navigate"]:
                        if self.blink % 2 == 0:
                            result = f"\u25b6 {val[0]} {val[2]}"
                        else: 
                            result = f"\u25b6 {val[0]} "
                    else: result = f"\u25b6 {val[0]} {val[2]}"  
                else:
                    result = f"{val[0]} {val[2]}"
                field.append(result)
            
            return (f"{'\u00A0'*5}".join(navigate), field)


        def get_deploy_map_display(self) -> dict:
            """Может глупое название, но создает и 
               возвращает словарь из словарей (если существуют) тек. состояния.
               Нужно для определения счетчика выбора в меню. (чтобы знать кол-во пунктов для выбора)"""
            
            curr_display: dict = dict()

            for upd in self.map_display:
                if upd:
                    curr_display.update(upd)

            return curr_display
            

        # - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        
        @property
        def state(self) -> int:
            return self._state

        @state.setter
        def state(self, value: int) -> None:
            self._state = value



        @property
        def substate(self) -> int:
            return self._substate

        @substate.setter
        def substate(self, value: int) -> None:
            self._substate = value



        @property
        def nav(self) -> int:
            return self._nav

        @nav.setter
        def nav(self, value: int) -> None:
            self._nav = value



        @property
        def motor(self) -> Motor:
            return self._motor

        @motor.setter   
        @inject
        def motor(self, obj) -> None:
            self._motor = obj
           
            

        @property
        def encoder(self) -> Encoder:
            return self._encoder

        @encoder.setter
        @inject
        def encoder(self, obj) -> None:
            self._encoder = obj



        @property
        def lcd(self) -> Lcd:
            return self._lcd

        @lcd.setter
        @inject
        def lcd(self, obj) -> None:
            self._lcd = obj

        

        def button_wheel(self) -> None:
            """Вызов по нажатии колеса мыши."""
            pass


        def round_wheel(self) -> None:
            """Вызов когда крутят енкодер + крутим мотор с передаточным числом"""
            
            self.lcd.write(f"___________{self.encoder.total_deg}", 3)
            self.motor.degstep = (self.encoder.deg_step * self.encoder.around_direction) / self.delta_reductor

        
    # ------------------------------- main --------------------------------------------------------------------

    lcd_display = Lcd("lcd", 12)
    man_encoder = Encoder("encoder", "encoder-svg")
    motor = Motor("val", "limb")
    controller = ATMega(lcd_display, man_encoder, motor)
    controller.run()
    @bind(document["power-on"], "click")
    def start_rotate(e):
        controller.lcd.on_power()
        

    @bind(document["power-off"], "click")
    def stop_rotate(e):
        controller.delta_reductor = 2.5
   
    </script>
      
    </body>
    </html>                  