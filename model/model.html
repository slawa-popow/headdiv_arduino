    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Симуляция устройства делительной головки</title>
        <script
        type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/brython@3.10.6/brython.min.js"
      ></script>
      <script
        type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/brython@3.10.6/brython_stdlib.js"
      ></script>

    <style>
    html {
        line-height: 1.4;
        font-weight: normal;
        font-size: 1rem;
        font-family: "Source Sans Pro", Arial, sans-serif;
        color: rgb(41, 41, 41);
    }
    body {
        margin: 0;
        padding: 0;
    }
    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 20px;
        margin-bottom: 30px;
        background-color: #c3cfe267; 
        border: 1px solid #c3cfe2;
    }
    header .title {
        text-transform: lowercase;
    }
    header .about {
        font-weight: normal;
        display: flex;
        flex-direction: column;
        flex-wrap: wrap;
    }
    .about a {
        font-size: 0.9em;
        font-weight: bold;
    }
    .svg-obj .lcontent {
        margin: 20px 40px;
        padding: 0 10px;
        width: 500px;
        height: 450px;
        border: 1px solid rgba(72, 114, 230, 0.493);
        float: left;
    }
    .svg-obj .rcontent {
        margin: 20px 0;
        padding: 20 10px;
        width: 695px;
        height: 450px;
        border: 1px solid rgba(72, 114, 230, 0.493);
        float: left; 
    }
    .cntcontent {
        width: 10px;            
        float: left;
        margin: 20px 10px;
        }
    .bcontent {
        clear: both;
        margin: 0 auto;
        padding: 50px 0;
        width: 95%;
    }
    .ttl {
        text-align: center;
        padding: 2px 0;
        margin-bottom: 50px;
        background-color: #c3cfe267; 
        border: 1px solid #c3cfe2;
    }
    .start{
        box-shadow:inset 0px 1px 0px 0px #9acc85;
        background:linear-gradient(to bottom, #74ad5a 5%, #68a54b 100%);
        background-color:#74ad5a;
        border-radius: 5px;
        border:1px solid #3b6e22;
        display:inline-block;
        cursor:pointer;
        color:#ffffff;
        padding:10px 16px;
        font-size: 1em;
        text-decoration:none;
        }
    .start:hover {
        background:linear-gradient(to bottom, #68a54b 5%, #74ad5a 100%);
        background-color:#68a54b;
        }
    .start:active {
        position:relative;
        top:1px;
        }
    .stop {
        box-shadow:inset 0px 1px 0px 0px #cf866c;
        background:linear-gradient(to bottom, #d0451b 5%, #bc3315 100%);
        background-color:#d0451b;
        border-radius:5px;
        border:1px solid #942911;
        display:inline-block;
        cursor:pointer;
        color:#ffffff;
        font-size: 1em;
        padding:10px 16px;
        text-decoration:none;
        text-shadow:0px 1px 0px #854629;
        }
    .stop:hover {
        background:linear-gradient(to bottom, #bc3315 5%, #d0451b 100%);
        background-color:#bc3315;
        }
    .stop:active {
        position:relative;
        top:1px;
        }
    button {
        box-shadow:inset 0px 1px 0px 0px #a6827e;
        background:linear-gradient(to bottom, #7d5d3b 5%, #634b30 100%);
        background-color:#7d5d3b;
        border-radius:5px;
        border:1px solid #54381e;
        display:inline-block;
        cursor:pointer;
        color:#ffffff;
        font-size:1em;
        padding:10px 16px;
        text-decoration:none;
        }
    button:hover {
        background:linear-gradient(to bottom, #634b30 5%, #7d5d3b 100%);
        background-color:#634b30;
        }
    button:active {
        position:relative;
        top:1px;
        } 
    .suply button {
        margin: 0 10px;
    } 
    pre{
        margin: 20px 0;
        width: 100%;
    }
    .bld {
        font-weight: bold;
        font-size: 0.9em;
        color: rgb(110, 65, 6);
    }
    .declaration {
        border: 1px dashed rgb(194, 187, 187);
        margin-bottom: 50px;
        padding: 8px 10px;
    }
    .declaration h1 {
        text-align: center;
        background-color: #efefef;
    }
    .declaration h3 {
        text-align: center;
        background-color: #b5e6a0ce;
    }
    .about-code {
        padding: 40px 20px;
        font-size: 0.8em
    }
    .about-code h1 {
        text-align: center;
        padding-bottom: 30px;
        font-size: 2.4em;
        font-weight: normal;
        border-bottom: 1px solid black;
    }
    .about-code ul {
          padding-left: 60px;
          list-style: square;
    }
    .about-code ul li{
        padding: 5px 0;
    }
    .about-code ul li a{
        font-size: 1.3em;
    }
    .table {
        width: 100%;
        margin: 50px auto;
        border: 1px solid #dddddd;
        border-collapse: collapse; 
    }
    .table th {
        font-weight: bold;
        padding: 5px;
        background: #efefef;
        border: 1px solid #dddddd;
    }
    .table td {
        border: 1px solid #dddddd;
        padding: 5px;
    }

    </style>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/idea.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
    </head>

    <body onload="brython(1)"> 
    <header>
        <h1 class="title">Модель-программа устройства делительной головки для станка</h1>
        <div class="about"> 
            <svg height="42" aria-hidden="true" viewBox="0 0 16 16" version="1.1" width="42"        data-view-component="true" class="octicon octicon-mark-github v-align-middle">
            <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
        <a href="https://github.com/slawa-popow/headdiv_arduino">проект</a>
       </div>
    </header>
    <section class="svg-obj">
    <div class="lcontent">
        <svg width="450" height="350" viewBox="0 0 250 150" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient gradientUnits="userSpaceOnUse" x1="171.645" y1="201.89" x2="171.645" y2="210.213" id="gradient-0" gradientTransform="matrix(0.510622, 0, 0, 1.081309, 128.372154, -157.130177)">
                <stop offset="0" style="stop-color: rgb(214, 214, 214);"></stop>
                <stop offset="0.416" style="stop-color: rgb(168, 168, 168);"></stop>
                <stop offset="0.518" style="stop-color: rgb(166, 166, 166);"></stop>
                <stop offset="1" style="stop-color: rgb(214, 214, 214);"></stop>
              </linearGradient>
            </defs>
            <g id="servo">
            <rect x="132.3" y="41.918" width="81.218" height="48" style="stroke: rgb(0, 0, 0); stroke-width: 0px; fill: rgb(122, 122, 122);"></rect>
            <rect x="132.645" y="42.175" width="6" height="48" style="fill: rgb(240, 240, 240); stroke: rgba(0, 0, 0, 0.17);"></rect>
            <rect x="207.123" y="42.175" width="6" height="47.304" style="fill: rgb(240, 240, 240); stroke: rgba(0, 0, 0, 0.17);"></rect>
            <rect x="213.517" y="61.175" width="5" height="9" style="stroke: rgb(0, 0, 0); stroke-width: 0px; fill: url(#gradient-0);"></rect>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="139.042" y1="80.641" x2="206.822" y2="80.641"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.744" y1="74.099" x2="206.524" y2="74.099"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.596" y1="66.814" x2="206.376" y2="66.814"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.744" y1="59.528" x2="206.524" y2="59.528"></line>
            <line style="fill: rgb(140, 140, 140); stroke: rgb(113, 110, 110);" x1="138.744" y1="52.54" x2="206.524" y2="52.54"></line>
            <rect style="fill: rgb(216, 216, 216); stroke: rgb(197, 188, 188);" x="31.483" y="36.745" width="100.666" height="90.741" rx="5" ry="5"></rect>
            <g id="val" transform-origin="82 81">
            <path style="paint-order: fill; stroke: rgb(80, 75, 75); fill: rgb(117, 147, 189);" d="M 82.168 70.275 C 90.464 70.275 95.65 79.257 91.501 86.442 C 87.353 93.627 76.982 93.627 72.834 86.442 C 69.826 81.233 71.665 74.57 76.918 71.641 L 78.068 76.269 L 83.295 74.868 L 82.168 70.275 Z"  ></path>
            </g>
            <circle id="limb" style="fill: none; stroke-width: 4px; stroke: rgb(138, 132, 132);" cx="82" cy="81.5" r="17"></circle>
            <text style="white-space: pre; fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12.3px;" x="153.031" y="178.119" transform="matrix(0.816774, 0, 0, 0.806308, -87.585098, -112.05706)">редуктор</text>
            <text style="white-space: pre; fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12.3px;" x="153.031" y="178.119" transform="matrix(0.848315, 0, 0, 0.813387, 49.176811, -111.468437)">мотор</text>
            <rect style="stroke: rgb(0, 0, 0); fill: none;" x="39.326" y="43.84" width="84.525" height="75.133" rx="5" ry="5"></rect>
         </g> 
        </svg>
    </div>
    <!--  -->
    <div class="cntcontent"></div>
    <!--  -->
    <div class="rcontent">
        <svg width="600" height="400" viewBox="0 0 400 200" 
        xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com">
            <defs>
              <radialGradient gradientUnits="userSpaceOnUse" cx="553.185" cy="313.038" 
              r="104.465" id="gradient-10" 
              gradientTransform="matrix(0.805315, -0.586333, 0.670928, 0.901363, -102.328976, 355.227791)">
                <stop offset="0" style="stop-color: rgb(225, 176, 96);"></stop>
                <stop offset="1" style="stop-color: rgb(133, 89, 35);"></stop>
              </radialGradient>
            </defs>
            
            <g transform="matrix(1, 0, 0, 1, 0, 0.269827)">
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="55.65" y1="132.237" x2="55.65" y2="147.357"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="65.287" y1="133.651" x2="65.287" y2="147.091"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="77.401" y1="131.795" x2="77.401" y2="146.915"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="87.569" y1="133.563" x2="87.569" y2="146.915"></line>
              <line style="stroke-width: 2px; stroke-linecap: round; fill: none; stroke: rgb(200, 200, 200);" x1="96.499" y1="133.829" x2="96.499" y2="146.65"></line>
              <g transform="matrix(1, 0, 0, 1, -1.069491, -0.763923)">
                <rect x="51.033" y="110.69" width="53.04" height="23.256" style="stroke: rgb(0, 0, 0); vector-effect: non-scaling-stroke; fill: rgba(82, 180, 49, 0.66);"></rect>
                <g transform="matrix(0.62624, 0.021869, 0.021869, -0.62624, 15.6054, 205.660828)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" d="M 126.564 126.466 C 127.81 125.869 129.621 122.583 128.694 120.978 C 127.767 119.373 125.45 119.372 124.523 120.978 C 123.842 122.157 125.005 125.863 126.206 126.504"></path>
                  <line style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" x1="126.42" y1="126.103" x2="126.235" y2="133.681"></line>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="1.259"></circle>
                </g>
                <g transform="matrix(0.62624, 0.021869, 0.021869, -0.62624, -3.451744, 206.020294)" >
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" d="M 126.564 126.466 C 127.81 125.869 129.621 122.583 128.694 120.978 C 127.767 119.373 125.45 119.372 124.523 120.978 C 123.842 122.157 125.005 125.863 126.206 126.504"></path>
                  <line style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" x1="126.42" y1="126.103" x2="126.235" y2="133.681"></line>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="1.259"></circle>
                </g>
                <g transform="matrix(0.890533, 0, 0, 0.890533, -46.515045, 15.501225)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 126.655 128.324 C 127.436 128.698 128.57 130.757 127.99 131.763 C 127.409 132.768 125.957 132.769 125.376 131.763 C 124.949 131.024 125.678 128.702 126.43 128.3" transform="matrix(0.999391, 0.0349, -0.0349, 0.999391, 4.628443, -4.34236)"></path>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="0.789" transform="matrix(0.999391, 0.0349, 0.0349, -0.999391, -8.816491, 247.268634)"></circle>
                  <path style="fill: none; stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 121.95 117.579 L 121.9 121.712 L 126.679 123.798 L 126.629 128.548"></path>
                </g>
                <g transform="matrix(1, 0, 0, 1, -0.152784, -0.305569)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 88.691 133.765 C 89.386 133.432 90.396 131.598 89.88 130.702 C 89.362 129.807 88.069 129.806 87.552 130.702 C 87.172 131.36 87.821 133.428 88.491 133.786" transform="matrix(-0.999391, 0.0349, -0.0349, -0.999391, 182.010373, 260.639327)"></path>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="0.703" transform="matrix(-0.999391, 0.0349, -0.0349, -0.999391, 223.73009, 250.266071)"></circle>
                  <path style="fill: none; stroke: rgb(58, 96, 25); stroke-width: 1.12292px; vector-effect: non-scaling-stroke;" d="M 88.793 130.251 L 88.748 126.571 L 93.004 124.713 L 92.96 120.483" transform="matrix(-1, 0, 0, -1, 181.751999, 250.734009)"></path>
                </g>
                <g transform="matrix(0.62624, 0.021869, 0.021869, -0.62624, -25.26741, 206.068115)">
                  <path style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" d="M 126.564 126.466 C 127.81 125.869 129.621 122.583 128.694 120.978 C 127.767 119.373 125.45 119.372 124.523 120.978 C 123.842 122.157 125.005 125.863 126.206 126.504"></path>
                  <line style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" x1="126.42" y1="126.103" x2="126.235" y2="133.681"></line>
                  <circle style="fill: rgb(217, 221, 219); stroke: rgb(58, 96, 25); stroke-width: 1.59586px; vector-effect: non-scaling-stroke;" cx="126.167" cy="135.028" r="1.259"></circle>
                </g>
              </g>
            </g>
            <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12px; white-space: pre;" x="16.636" y="17.109">энкодер</text>
           <g id="lcd">
            <rect  style="fill: rgb(158, 182, 121); stroke-width: 3px; stroke: rgb(88, 85, 75);" x="190" y="33" width="180" height="125" rx="3" ry="3" ></rect>
            </g>
            <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 12px; white-space: pre;" x="190.548" y="20.798">LCD</text>
            <g id="encoder" transform-origin="77 73" transform="matrix(0.999999, 0, 0, 0.999999, 0.000041, 0.000206)" >
              <g transform="matrix(1, 0, 0.000001, 0.989012, -0.407998, -16.634939)">
                <path id="encoder-svg" style="stroke: rgb(0, 0, 0); fill: url(#gradient-10);" transform="matrix(0.430767, 0, 0, 0.435553, -160.723328, -45.253071)" d="M 548.60465399 211.683 L 557.76534601 211.683 L 562.163755299 208.573152069 A 104.85 104.85 0 0 1 571.549680557 209.808832571 L 574.993329812 213.951107096 L 583.841878821 216.322068657 L 588.895303819 214.456578317 A 104.85 104.85 0 0 1 597.641593782 218.07941024 L 599.895803997 222.971822194 L 607.829196003 227.552168204 L 613.193254149 227.058165539 A 104.85 104.85 0 0 1 620.703863609 232.821258874 L 621.615014083 238.130398469 L 628.092601531 244.607985917 L 633.401741126 245.519136391 A 104.85 104.85 0 0 1 639.164834461 253.029745851 L 638.670831796 258.393803997 L 643.251177806 266.327196003 L 648.14358976 268.581406218 A 104.85 104.85 0 0 1 651.766421683 277.327696181 L 649.900931343 282.381121179 L 652.271892904 291.229670188 L 656.414167429 294.673319443 A 104.85 104.85 0 0 1 657.649847931 304.059244701 L 654.54 308.45765399 L 654.54 317.61834601 L 657.649847931 322.016755299 A 104.85 104.85 0 0 1 656.414167429 331.402680557 L 652.271892904 334.846329812 L 649.900931343 343.694878821 L 651.766421683 348.748303819 A 104.85 104.85 0 0 1 648.14358976 357.494593782 L 643.251177806 359.748803997 L 638.670831796 367.682196003 L 639.164834461 373.046254149 A 104.85 104.85 0 0 1 633.401741126 380.556863609 L 628.092601531 381.468014083 L 621.615014083 387.945601531 L 620.703863609 393.254741126 A 104.85 104.85 0 0 1 613.193254149 399.017834461 L 607.829196003 398.523831796 L 599.895803997 403.104177806 L 597.641593782 407.99658976 A 104.85 104.85 0 0 1 588.895303819 411.619421683 L 583.841878821 409.753931343 L 574.993329812 412.124892904 L 571.549680557 416.267167429 A 104.85 104.85 0 0 1 562.163755299 417.502847931 L 557.76534601 414.393 L 548.60465399 414.393 L 544.206244701 417.502847931 A 104.85 104.85 0 0 1 534.820319443 416.267167429 L 531.376670188 412.124892904 L 522.528121179 409.753931343 L 517.474696181 411.619421683 A 104.85 104.85 0 0 1 508.728406218 407.99658976 L 506.474196003 403.104177806 L 498.540803997 398.523831796 L 493.176745851 399.017834461 A 104.85 104.85 0 0 1 485.666136391 393.254741126 L 484.754985917 387.945601531 L 478.277398469 381.468014083 L 472.968258874 380.556863609 A 104.85 104.85 0 0 1 467.205165539 373.046254149 L 467.699168204 367.682196003 L 463.118822194 359.748803997 L 458.22641024 357.494593782 A 104.85 104.85 0 0 1 454.603578317 348.748303819 L 456.469068657 343.694878821 L 454.098107096 334.846329812 L 449.955832571 331.402680557 A 104.85 104.85 0 0 1 448.720152069 322.016755299 L 451.83 317.61834601 L 451.83 308.45765399 L 448.720152069 304.059244701 A 104.85 104.85 0 0 1 449.955832571 294.673319443 L 454.098107096 291.229670188 L 456.469068657 282.381121179 L 454.603578317 277.327696181 A 104.85 104.85 0 0 1 458.22641024 268.581406218 L 463.118822194 266.327196003 L 467.699168204 258.393803997 L 467.205165539 253.029745851 A 104.85 104.85 0 0 1 472.968258874 245.519136391 L 478.277398469 244.607985917 L 484.754985917 238.130398469 L 485.666136391 232.821258874 A 104.85 104.85 0 0 1 493.176745851 227.058165539 L 498.540803997 227.552168204 L 506.474196003 222.971822194 L 508.728406218 218.07941024 A 104.85 104.85 0 0 1 517.474696181 214.456578317 L 522.528121179 216.322068657 L 531.376670188 213.951107096 L 534.820319443 209.808832571 A 104.85 104.85 0 0 1 544.206244701 208.573152069 Z M 553.185 313.038 A 0 0 0 0 0 553.185 313.038 A 0 0 0 0 0 553.185 313.038" bx:shape="cog 553.185 313.038 0 104.85 101.355 0.31 24 1@c59c0b7b"></path>
                <circle style="fill: none; vector-effect: non-scaling-stroke; stroke: rgb(135, 96, 17);" cx="77.759" cy="90.749" r="32.317"></circle>
              </g>
              <line style="fill: none; stroke: rgb(188, 183, 171);" x1="77.678" y1="73.323" x2="93.689" y2="32.659"></line>
            </g>

              
           <svg xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com"
            width=200 height=100 viewBox="0 0 200 100" id="Capa_1" x=200 y=180
            <defs>
              <radialGradient gradientUnits="userSpaceOnUse" cx="135.948" cy="66.428" r="79.294" id="gradient-50" gradientTransform="matrix(0.199279, 1.245322, -1.227635, 0.196449, 162.715485, -59.408054)">
                <stop offset="0" style="stop-color: rgb(255, 199, 120);"></stop>
                <stop offset="1" style="stop-color: rgb(188, 127, 41);"></stop>
              </radialGradient>
            </defs>
            <g id="hand-push"  transform="matrix(0.285881, 0, 0, 0.288069, 53.521637, -0.692086)">
              <g>
                <g>
                  <g transform="matrix(0.5722, 0, 0, 0.5722, -105.686287, 47.097092)" >
                    <path d="M 143.426 78.081 C 137.975 78.081 133.21 80.967 130.538 85.285 L 130.538 80.354 C 130.538 71.981 123.75 65.193 115.377 65.193 C 109.926 65.193 105.161 68.079 102.489 72.397 L 102.489 68.983 C 102.489 60.61 95.701 53.822 87.328 53.822 C 81.877 53.822 77.112 56.708 74.44 61.026 L 74.44 15.161 C 74.44 6.788 67.652 0 59.279 0 C 50.906 0 44.118 6.788 44.118 15.161 L 44.118 129.216 L 27.117 107.418 C 21.968 100.815 12.44 99.637 5.838 104.787 C -0.765 109.936 -1.942 119.464 3.207 126.066 L 50.872 187.18 C 58.048 197.876 70.248 204.931 84.067 204.931 L 113.744 204.931 C 137.976 204.931 158.588 185.296 158.588 160.087 C 158.588 153.284 158.588 99.378 158.588 93.241 C 158.587 84.869 151.799 78.081 143.426 78.081 Z" style="fill: url(#gradient-50);" transform="matrix(-1, 0, 0, -1, 158.588298, 204.931)"></path>
                    <path id="lamp-push" d="M 62.72 236.492 C 68.242 236.492 72.72 232.015 72.72 226.492 C 72.72 211.831 84.647 199.903 99.308 199.903 C 113.968 199.903 125.896 211.831 125.896 226.492 C 125.896 232.015 130.374 236.492 135.896 236.492 C 141.418 236.492 145.896 232.015 145.896 226.492 C 145.895 200.802 124.996 179.903 99.308 179.903 C 73.62 179.903 52.72 200.802 52.72 226.492 C 52.72 232.014 57.197 236.492 62.72 236.492 Z" style="fill: rgb(147, 22, 0);" transform="matrix(-1, 0, 0, -1, 198.615997, 416.395004)"></path>
                  </g>
                  <text id="text-hand-push"style="fill: rgb(51, 51, 51); font-size: 42px; line-height: 58px;" x="-167" y="30" >не нажато</text>
                </g>
              </g>
            </g>
          </svg>
          </svg>
          <!--  -->
          
          <div class="suply">
            <button class="start" id="power-on" disabled>включить</button>
            <button class="stop" id="power-off" disabled>отключить</button>
            <button id="man-mode" >вращать ручн.</button>
          </div>
    </div>
    <!--  -->
    <div class="bcontent">
    <div class="declaration">
        <h1>Как пользоваться</h1>
        <p>Для нормальной работы программы нужно, чтобы устройство, на котором открыт этот html файл, было подключено к сети интернет (документ загружает из сети транслятор python - Brython и скрипт подсветки кода), а также к устройству должна быть подсоединена мышь (т-к программа работает как симулятор управления электронным устройством енкодером вместо кнопок).
            У меня нормально работает в браузерах: chrome, mozilla firefox.
        </p>
        <p>Программа состоит из 3-х веток: 
            <dl>
                <dt></dt>
                <dd><u>равномерная разметка</u></dd>
                <dd><u>не равномерная разметка</u></dd>
                <dd><u>глобальные настройки</u></dd>
            </dl>
       <p>Также есть возможность прокручивать вал мотора вращая ручку енкодера. Для этого есть коричневая кнопка <u>вращать ручн.</u> над коротой рисунок руки с красным полумесяцем под пальцем. и текстом <b>"не нажато"</b></p> 
       <p>Этот режим доступен только из главного меню пограммы <b>"равномерная разметка?"</b> Если нажать на кнопку <u>вращение ручн.</u> находясь в главном разделе меню, то цвет полумесяца под пальцем рисунка руки изменится на зеленый и сменится надпись на <b>"удержание кнопки"</b>. 
            При наведении указателя мыши на рисунок енкодера и вращении колесика мыши вверх или вниз вал будет вращаться влево или вправо. Нажав на кнопку <u>вращение ручн.</u> еще раз, программа выйдет из режима ручного вращения и при вращении колесика мыши будут выделятся пункты меню на дисплее. 
            В реальном устройстве будет кнопка, которую нужно нажать, держать и крутить енкодер для поворота вала как угодно. 
       </p> 
       <h3>глобальные настройки. пункт пеню: <u>настр.</u></h3>
       <p>Находясь в главном меню (когда документ загрузится, то дисплей имитирует включение подсветки и загружается главное меню. После обновление страницы в браузере - тоже самое) убедиться
        что не нажата кнопка <u>вращать ручн.</u> (если была нажата, нажать еще раз) навести указатель мыши на енкодер. Енкодер сменит цвет обводки на красный и изменится значок указателя мыши. Вращая колесико мыши выбрать пункт  <b> &#x25b6;настр.&#x25c0;</b>
        и нажать на колесико мыши. 
       </p>
       <p>
        Перешли в меню настроек. В этом меню три пункта для изменения: 
        <dl>
            <dt><u>передат. число: 1.0</u></dt>
            <dd>Настройка передаточного числа мотор-редуктора. Влияет на скорость вращения вала и точность. В этой программе влияет только на скорость.
                Значение 1.0 значит 1/1. Если увеличить, то общая скорость вращения вала будет маленькая
            </dd>
            <dt><u>cкорость авто: 0.8</u></dt>
            <dd>
                Скорость вращения в режиме автоматической разметки. Автоматическая разметка это <u>равномерная разметка</u> и <u>не равномерная разметка</u>.
                Если увеличить, то скорость вращения вала увеличится.
            </dd>
            <dt><u>скорость ручн.: 1</u></dt>
            <dd>
                Скорость вращения в ручном режиме (когда удерживается кнопка <b>вращать ручн.</b>). На сколько градусов сразу повернуть вал двигателя за один "микроповорот" ручки енкодера. Короче тут лучше самому посмотреть как работает.
            </dd>
        </dl>
       </p>
       <p>
        Вращая колесико мыши выбираем нужный пункт, далее нажимаем снова на колесико мыши, выбранный нами пункт начнет мигать (вернее его изменяемое значение), крутим колесико мыши вверх/вниз для увеличения/уменьшения
        значения. Программа блокирует числа меньше или равные нулю, а также больше 360. Настроив значение нужно нажать на колесико мыши еще раз. Программа сохранит значение и вернет вращению колесика мыши функцию навигации.
        Далее выбираем <b> &#x25b6;да&#x25c0;</b>. Программа выходит в главное меню с новыми значениями настроек до первой перезагрузке страницы в браузере.
       </p>
       <h3>равномерная разметка. пункт меню:  <u> да </u></h3>
        <p>Выбираем пункт <b> &#x25b6;количество:</b></p> нажимаем колесико мыши, значение начнет мигать, крутим колесико мыши для изменения, нажимаем колесико мыши для
           сохранения значения. Выбираем <b> &#x25b6;да&#x25c0;</b>
        </p>
        <p>
            В этой ветке программы мнимая окружность разбивается на равные части от 1 до 360, изменяя пункт <b>количество:</b>
            подпункт <b>градусов:</b> автоматически расчитывает сколько будет градусов между точками. Например: <u>количество: 9</u> <u>градусов: 40</u>,
            после выбора окружность будет разбита на 9 равных частей по 40 градусов между точками.
        </p>
        <p>
            После ввода кол-ва частей и нажатии на пункте <b>да</b> мы переходим на предпусковой экран программы. Здесь отображается информация о кол-ве разбитых точек итд.
            Также на рисунке мотор-редуктора вокруг вала будут нарисованы кружки - точки на которые мы разбили окружность. Рядом с точками надписи кол-во градусов отсосительно нуля.
            Положение нуля одинаково для всех режимов работы. Предполагается, что в нулевой точке находится инстумент.
        </p>
        <p>
            Тут мы можем выбрать пункт <b>отмена</b> и вернуться в главное меню. Если нажать <b>да</b>, то произойдет запуск программы автоматической разметки.
            Стрелка с валом будет вращаться до ближайшей точки, когда стрелка подойдет к точке, точка окрасится из фиолетового в зеленый цвет и программа встанет на паузу.
            Предполагается что теперь можно например сверлить, кернить, фрезеровать итд. Для продолжения нужно нажать <b>продолжить</b>. Если нажать <b>отмена</b>, то мы вернемся в главное меню.
            Когда вал сделает полный оборот программа закочится и мы вернемся в главное меню.
        </p>
        <h3>не равномерная разметка. пункт меню:  <u> нет </u></h3>
        Указываем общее количество точек, на которые будет разбита окружность. Разбита окружность будет не равномерно. По умолчанию (если ничего не менять, а нажать <b>добавить</b> )
        будут созданы и нарисованы на мотор-редукторе 4 точки отодвинутые на 20 грудусов друг от друга. Точки 4, а пунктов для редактирования 3. Эти пункты - это промежутки между точками.
        Изменяя промежутки, точки на мотор-редукторе автоматически перерисовываются (двигаются). Если мы добавили много точек, то поля редактирования для их промежутков не влезут в дисплей. Нужно вращать колесико мышки. Короче 
        это как в браузере мемасики прокручивать на сайте. Изменяем/не изменяем промежутки, нажимаем <b>да</b> и программа разметки стартует сразу. Если в меню редактирования нажать <b>отмена</b>
        то возвращаемся в главное меню. Работае так же как и ветка <u>равномерная разметка</u>.


    </div>
    <div class="about-code">
        <h1>описание работы кода скрипта</h1>
        <ul>
            <li><a href="#graphic">графика</a>
            <li><a href="#uml">объектная модель</a></li>
            <li><a href="#class-Display">class Display:</a></li>
            <li><a href="#class-Lcd">class Lcd:</a></li>
            <li><a href="#class-Encoder">class Encoder:</a></li>
            <li><a href="#class-Motor">class Motor:</a></li>
            <li><a href="#class-atmega">class ATMega:</a>
                <ul>
                    <li><a href="#attributes-mega">атрибуты:</a></li>
                    <li><a href="#methods">методы</a></li>
                    <li><a href="#state-mashine">машина состояний (конечный автомат)</a></li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="ttl" id="graphic"><h2>Графика.</h2></div>   
   
    <p>Скрипт написан на python3. Его обработкой и трансляцией в javascript занимается <a href="https://brython.info/">Brython</a>,  который подгружаем в теле тега <span class="bld"> head</span>, там же подгружаем штуку для подсвечивания кода highlight. </p>
    <p>SVG объекты нарисованы в программе <a href="https://boxy-svg.com/">boxy-svg</a>
        это приложение для браузера chrome. 
    </p> 
    <p>
        В левом <span class="bld">div class="lcontent" </span>  расположен один svg <span class="bld">viewBox </span>, в котором расположены объекты двигателя,
        корпуса редуктора, вала. Вал серо-синего цвета. К валу в программе применяется <span class="bld"> transform: rotate(deg).</span>
        Вал <span class="bld">(path) </span> вложен в группу <span class="bld">g id="val" transform-origin="82 81". </span> Центр объекта (группы g) вала вокруг которого он будет вращаться
        находим следующей функцией:
        <pre><code class="python">
        def get_center(svg_id: str) -> tuple:
            """ Принимает id svg объектa. Возвращает
                координаты x, y центра объектa."""
            
            bb = document[svg_id].getBBox()
            return (int(bb.x + bb.width / 2), int(bb.y + bb.height / 2))
            
        print(get_center("val"))
        </code></pre>
        Вызов функции <span class="bld">print(get_center("val")) </span>  произвести в глобальной области видимости. Выведенные значения кортежа в консоль браузера нужно записать в  <span class="bld">transform-origin </span> объекта. Если такого атрибута нет, создать. Всегда нужно находить и задавать центр той фигуры, которую нужно вращать, иначе она будет вращаться вокруг центра общей системы координат.
    </p>   
     <p>Масштаб фигур  <span class="bld">svg width="450" height="350" viewBox="0 0 250 150"</span> подбираем опытным путем с разницей 200 пикселей, т-е ширина и высота на 200px больше <span class="bld">width height viewBox</span>, а <span class="bld">min-x min-y viewBox</span> - нули. </p>  
     <table class="table" style="width: 45%;">
        <caption>id svg объектов мотор-редуктора:</caption>
        <thead>
            <tr>
                <th>объект</th>
                <th>id</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>вал</td>
                <td>"val"</td>
            </tr>
            <tr>
                <td>редуктор + вал + кругляк(группа g)</td>
                <td>"servo"</td>
            </tr>
            <tr>
                <td>кругляк вокруг вала</td>
                <td>"limb"</td>
            </tr>
        </tbody>
     </table>

    <p>Cправа вo <span class="bld">div class="rcontent" </span> у нас второй svg вьюбокс, в него вложен третий вьюбокc руки над кнопкой.
     Во втором находятся енкодер - составной объект, дисплей - прямоугольник. Оба внутри тега своей группы. Енкодер состоит из пути <span class="bld">path</span> - это ручка с зубцами, линии и внутренней декоративной окружности.
     Путь <span class="bld">path</span> имеет свой <span class="bld">id="encoder-svg" </span> для доступа к его атрибуту <span class="bld">style="stroke: rgb(0, 0, 0); </span> для смены цвета по наведении указателя мыши.
     Ручка имеет свой <span class="bld">id="encoder" </span> и <span class="bld"> transform-origin="77 73"</span> центр для вращения по наведении указателя мыши и вращении колесика мышки. 
    </p>
    <p>
        К ручке енкодера и руки над кнопкой применены градиенты созданные в программе. Бывает такое что градиент не применяется. Нужно сменить id svg тега <span class="bld">radialGradient </span> на что-то уникальное, и измененный id заменить в атрибуте <span class="bld">style: fill </span> окрашиваемого объектa.
    </p>
    <p>Линия-маркер находится в группе ручки, поэтому вращается вместе с ней.</p>

    <table class="table" style="width: 45%;">
        <caption>id svg объектов енкодера, дисплея и руки:</caption>
        <thead>
            <tr>
                <th>объект</th>
                <th>id</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>группа ручки и линии</td>
                <td>"encoder"</td>
            </tr>
            <tr>
                <td>обводка ручки</td>
                <td>"encoder-svg"</td>
            </tr>
            <tr>
                <td>дисплей группа</td>
                <td>"lcd"</td>
            </tr>
            <tr>
                <td>рука над кнопкой</td>
                <td>"hand-push"</td>
            </tr>
            <tr>
                <td>полумесяц под рукой</td>
                <td>"lamp-push"</td>
            </tr>
            <tr>
                <td>текст над рукой</td>
                <td>"text-hand-push"</td>
            </tr>
        </tbody>
     </table>
    <p>Полумесяц под рукой меняет цвет в состоянии имитации нажатия и удержании кнопки "вращать ручн.".</p>

    <div class="ttl" id="uml"><h2>Объектная модель.</h2></div>
     <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/PR-SVG-20010719/DTD/svg10.dtd">
<svg width="1400" height="1200" viewBox="60 263 1550 1450" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <g id="Фон">
    <g>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="198" y="364.5" width="248.7" height="28"/>
      <text font-size="16" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:normal;font-weight:700" x="322.35" y="383.352">Component</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="198" y="392.5" width="248.7" height="36"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="201" y="406.381">#_mega: ATMega = None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="201" y="422.381">+mega: @property</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="198" y="428.5" width="248.7" height="20"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="201" y="442.381">+&lt;&lt;конструктор&gt;&gt; __init__(self)</text>
    </g>
    <g>
      <polyline style="fill: none; stroke-opacity: 1; stroke-width: 2; stroke: #000000" points="198,466.736 198,495.25 301.922,495.25 301.922,555.601 "/>
      <polygon style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" fill-rule="evenodd" points="206,466.736 198,450.736 190,466.736 "/>
    </g>
    <g>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="12.0223" y="556.604" width="579.8" height="28"/>
      <text font-size="16" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:normal;font-weight:700" x="301.922" y="575.456">Display</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="12.0223" y="584.604" width="579.8" height="212"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="598.485">#_mega: ATMega = None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="614.485">#_id_lcd: &lt;SVGGElement id="lcd"&gt;</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="630.485">#_size_char: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="646.485">#_line_height: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="662.485">#_x: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="678.485">#_y: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="694.485">#_width: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="710.485">#_height: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="726.485">#_first_line_coord: tuple</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="742.485">#_max_lines: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="758.485">#_lines_coords: dict</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="774.485">#_svg_lines: dict</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="790.485">#_max_len: int</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="12.0223" y="796.604" width="579.8" height="84"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="810.485">+&lt;&lt;конструктор&gt;&gt; __init__(self,id_svg:str,size_char:int,line_height:int=2)</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:italic;font-weight:normal" x="15.0223" y="826.485">-__get_lines_coords(self): dict</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:italic;font-weight:normal" x="15.0223" y="842.485">-__get_coords_first_line(self): tuple</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="858.485">+ write(self,wtext:str,line:int): None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="15.0223" y="874.485">+clean(self,line:int=None): None</text>
    </g>
    <g>
      <polyline style="fill: none; stroke-opacity: 1; stroke-width: 2; stroke: #000000" points="301.922,899.85 301.922,937.605 228.622,937.605 228.622,977.596 "/>
      <polygon style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" fill-rule="evenodd" points="309.922,899.85 301.922,883.85 293.922,899.85 "/>
    </g>
    <g>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="8.0223" y="978.604" width="441.2" height="28"/>
      <text font-size="16" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:normal;font-weight:700" x="228.622" y="997.456">Lcd</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="8.0223" y="1006.6" width="441.2" height="52"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="11.0223" y="1020.49">+id: @property</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="11.0223" y="1036.49">+strlen: @property</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="11.0223" y="1052.49">#_mega: ATMega</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="8.0223" y="1058.6" width="441.2" height="52"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="11.0223" y="1072.49">+&lt;&lt;конструктор&gt;&gt; __init__(self,id_svg:str,size_char:int)</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="11.0223" y="1088.49">+on_power(self): None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="11.0223" y="1104.49">+off_power(self): None</text>
    </g>
    <g>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="489.532" y="982.344" width="479.7" height="28"/>
      <text font-size="16" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:normal;font-weight:700" x="729.382" y="1001.2">Encoder</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="489.532" y="1010.34" width="479.7" height="116"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1024.22">+deg_step: @property</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1040.22">+total_deg: @property</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1056.22">+around_direction: int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1072.22">+navigator: list</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1088.22">#_mega: ATMega = None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1104.22">#_id: SVGGElement</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1120.22">#_path_id: SVGPathElement</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="489.532" y="1126.34" width="479.7" height="68"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1140.22">+&lt;&lt;конструктор&gt;&gt; __init__(id_encoder:str,id_encoder_path:str)</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1156.22">+&lt;&lt;обработчик событий&gt;&gt; wheel(self,e): None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1172.22">+&lt;&lt;обработчик событий&gt;&gt; select_encoder(self,e): None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="492.532" y="1188.22">+&lt;&lt;обработчик событий &gt;&gt; click_wheel(self,e): None</text>
    </g>
    <g>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="764.043" y="690.954" width="756.9" height="28"/>
      <text font-size="16" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:normal;font-weight:700" x="1142.49" y="709.805">Motor</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="764.043" y="718.954" width="756.9" height="148"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="732.835">+id: @property = SVGGElement</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="748.835">+limb: @property = SVGCircleElement</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="764.835">+degstep: @property = int</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="780.835">+points: dict = dict()</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="796.835">+text_deg_point: list = list()</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="812.835">+gservo: SVGGElement</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="828.835">+arrow_line: SVGLineElement = None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="844.835">#_mega: ATMega = None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="860.835">#_total_d: float = 0</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="764.043" y="866.954" width="756.9" height="68"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="880.835">+&lt;&lt;конструктор&gt;&gt; __init__(self,id_val:str,id_limb:str)</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="896.835">+&lt;&lt;создает кружки/текст вокруг вала&gt;&gt; create_points(self,num_points:int,deg_pos:float=None): None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="912.835">+&lt;&lt;удаляет кружки вокруг вала&gt;&gt; delete_points(self): None</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="767.043" y="928.835">+null_position(self): None</text>
    </g>
    <g>
      <polyline style="fill: none; stroke-opacity: 1; stroke-width: 2; stroke: #000000" points="322.35,467.728 322.35,496.23 729.382,496.23 729.382,981.352 "/>
      <polygon style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" fill-rule="evenodd" points="330.35,467.728 322.35,451.728 314.35,467.728 "/>
    </g>
    <g>
      <polyline style="fill: none; stroke-opacity: 1; stroke-width: 2; stroke: #000000" points="465.93,406.5 1066.89,406.5 1066.89,688.309 1060.89,688.309 "/>
      <polygon style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" fill-rule="evenodd" points="465.93,398.5 449.93,406.5 465.93,414.5 "/>
    </g>
    <g>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="228.895" y="1307.81" width="525.9" height="156"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:monospace;font-style:normal;font-weight:normal" x="491.845" y="1323.69">&lt;&lt;Микроконтроллер&gt;&gt;</text>
      <text font-size="16" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:normal;font-weight:700" x="491.845" y="1342.66">ATMega</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1358.2">Список атрибутов</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1372.2">и методов</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1386.2">слишком длинный,</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1400.2">чтобы описывать</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1414.2">их здесь.</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1428.2">Описание будет</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1442.2">отдельно в</text>
      <text font-size="11.2" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:middle;font-family:sans-serif;font-style:italic;font-weight:normal" x="491.845" y="1456.2">таблице.</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="228.895" y="1463.81" width="525.9" height="68"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="231.895" y="1477.69">+lcd: @property = __main__.Lcd object</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="231.895" y="1493.69">+encoder: @property = __main__.Encoder object</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="231.895" y="1509.69">+motor: @property = __main__.Motor object</text>
      <text xml:space="preserve" font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="231.895" y="1525.69"> . . .</text>
      <rect style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" x="228.895" y="1531.81" width="525.9" height="52"/>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="231.895" y="1545.69">+&lt;&lt;конструктор&gt;&gt; __init__(self,lcd:Lcd,encoder:Encoder,motor:Motor)</text>
      <text font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="231.895" y="1561.69">+&lt;&lt;Пуск машины состояний&gt;&gt; run(self): None</text>
      <text xml:space="preserve" font-size="12.8" style="fill: #000000; fill-opacity: 1; stroke: none;text-anchor:start;font-family:monospace;font-style:normal;font-weight:normal" x="231.895" y="1577.69"> . . .()</text>
    </g>
    <g>
      <polyline style="fill: none; stroke-opacity: 1; stroke-width: 2; stroke: #000000" points="412.649,1278.8 412.649,1199.38 149.426,1199.38 149.426,1108.78 "/>
      <polygon style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" fill-rule="evenodd" points="412.649,1303.97 407.849,1289.97 412.649,1275.97 417.449,1289.97 "/>
    </g>
    <g>
      <polyline style="fill: none; stroke-opacity: 1; stroke-width: 2; stroke: #000000" points="491.845,1281.63 491.845,1244.08 729.382,1244.08 729.382,1195.35 "/>
      <polygon style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" fill-rule="evenodd" points="491.845,1306.8 487.045,1292.8 491.845,1278.8 496.645,1292.8 "/>
    </g>
    <g>
      <polyline style="fill: none; stroke-opacity: 1; stroke-width: 2; stroke: #000000" points="779.967,1385.81 1025.41,1385.81 1025.41,938.582 1021.16,938.582 "/>
      <polygon style="fill: #ffffff; fill-opacity: 1; stroke-opacity: 1; stroke-width: 2; stroke: #000000" fill-rule="evenodd" points="754.795,1385.81 768.795,1381.01 782.795,1385.81 768.795,1390.61 "/>
    </g>
  </g>
</svg>

    <p>
        По UML диаграмме можно рассмотреть некоторое сходство с поведенческим паттерном "Посредник (Mediator)". Мне было необходимо, чтобы между главным объектом класса ATMega и объектами-компонентами (дисплей, мотор, енкодер) была двусторонняя связь и при этом общаться каждый из объектов-компонентов должен был только с ATMega.
        Как в реальности - дисплей не может ничего передать драйверу шагового мотора и наоборот без микроконтроллера. Енкодер может послать импульсы драйверу, но не надо. В отличии от классической структуры паттерна, в этой структуре я не добавлял интерфейс, т-к посчитал излишним конкретно для этого скрипта. 
    </p>
    <p>
        Все классы компонентов (дисплей, мотор, енкодер) наследуют от класса <span class="bld"> Component</span> свойства <span class="bld">@property</span>, это будут ссылки на объект ATMega с начальным значением <span class="bld">None</span>. 
        Сначала создаются объекты-компоненты (дисплей, мотор и пр), ссылки этих объектов передаются как аргументы конструктору ATMega:</p>
    <pre><code class="python">
        lcd_display = Lcd("lcd", 12)
        man_encoder = Encoder("encoder", "encoder-svg")
        motor = Motor("val", "limb")
        controller = ATMega(lcd_display, man_encoder, motor)
    </code></pre>
    <p>
        В конструкторе <span class="bld">__init__</span> ATMega значения параметров присваиваются атрибутам-свойствам (вызываются <span class="bld">@property.setter</span>) методы. 
    </p> 
    <pre><code class="python">
        def __init__(self, lcd: Lcd, encoder: Encoder, motor: Motor) -> None:
            self.lcd = lcd
            self.encoder = encoder
            self.motor = motor
            . . .
    </code></pre>        
    <p>Вот структура геттеров и сеттеров для работы с объектами-компонентами (дисплей, мотор итд:)</p>
    <pre><code class="python">
        @property
        def motor(self) -> Motor:
            return self._motor

        @motor.setter   
        @inject
        def motor(self, obj) -> None:
            self._motor = obj 
    </code></pre>
    <p>Как видно сеттер оборачивает декоратор <span class="bld">@inject</span>. Я решил так сделать, чтобы убрать дублирующийся код. Из комментария декоратора можно подумать что порядок вызова декорируемого метода и присваивания ссылки объекта ATMega атрибуту объектов-компонентов имеет значение. Порядок не имеет значения, просто таков был ход моей мысли.</p>
    <pre><code class="python">
        def inject(method_setter: Callable) -> Callable:
            """Декоратор для сеттеров. Внедряет объект ATMega в объект каждой компоненты
            до присваивания соотв. атрибута экземпляра ATMega. """
        
            @wraps(method_setter)
            def wrapper(self, obj) -> None:
                obj.mega = self
                method_setter(self, obj)
            
            return wrapper
    </code></pre>
    <p>Теперь объект <span class="bld">controller</span> имеет доступ к каждому из объектов, переданному его конструктору  и каждый из этих переданных объектов имеет также доступ только к контроллеру.</p>
    
    <div class="ttl" id="class-Display"><h2>class Display</h2></div>
    <!-- {'__thisclass__': <class '__main__.Display'>, '__self_class__': <__main__.Lcd object>} -->
    <p>Класс <span class="bld">Display</span> потомок класса <span class="bld">Component</span>.
        Для работы с дисплеем у меня 2 класса: этот родительский и его потомок класс <span class="bld">Lcd</span>. От этого мне нужно чтобы SVG прямоугольник-дисплей при изменении своего размера или координат
        не искажал каким либо образом "записанную" в него текстовую информацию. Т-е текст на дисплее всегда был на своем месте независимо от положения или размеров прямоугольника-дисплея. Единственное что, например при  
        расширении дисплея, увеличится кол-во строк (если увеличивать высоту) и/или длинна строки (если увеличивать ширину). Поэтому в конструктор при создании объекта передается помимо id SVG дисплея, еще и размер шрифта. Также от 
        этого класса нужна информация о кол-ве строк и длинны строки. Еще здесь реализованы метод вывода на дисплей строк (создание объектов SVGTextElement текста и их добавление в структуру SVG), метод очистки всего экрана (или № строки) дисплея (удаление SVGTextElement объектов текста из SVG cтруктуры). 
        В этом классе нет <span class="bld">property</span> свойств, кроме <span class="bld">self.mega</span>. Объекты-свойства будут в классе <span class="bld">Lcd</span> + унаследованный отсюда функционал.
    </p>
    <pre><code class="python">
    class Display(Component):
        '''Родительский класс дисплея. Делает закулисную грязную работу. Будет
           вычислять атрибуты: число строк, длинна строки, координаты начала строки
           размеры дисплея...'''

        
        def __init__(self, id_svg: str, size_char: int, line_height=2) -> None:
            super().__init__()
            
                # объект svg <g> дисплея
            self._id_lcd = document[id_svg]

                # размер шрифта (высота символа) в пикселях. т-е число int это размер в пикселях.
            self._size_char = size_char

                # межстрочный интервал px
            self._line_height = line_height
            
                # cоздаю атрибуты из полученных данных от getBBox():
                # self._x, self._y -- координаты фигуры 
                # self._width, self._height -- ширина, высота фигуры

            for name_attr, value_attr in dict(self._id_lcd.getBBox()).items():
                super().__setattr__("_" + name_attr, value_attr)
            
                # координаты первой строки
            self._first_line_coord: tuple = self.__get_coords_first_line()

                # макс. число строк с учетом высоты символа + межстрочного интевала
            self._max_lines: int = self._height // (self._size_char+self._line_height)

                # словарь {№строки : координаты(X, Y)}
            self._lines_coords: dict = self.__get_lines_coords()
                
                # словарь обЪектов строк. Строки добавляются в write()
            self._svg_lines: dict = dict()

                # макс. длинна строки (символов). 4 - от балды взято (на самом деле с 4 расчет более-менее правильный)
            self._max_len: int = (self._width + self._first_line_coord[0]) // (self._size_char + 4)
            

        # ---------------------------------------------------------------------------------------------------

        def __get_lines_coords(self) -> dict:
            """Возвращает словарь с вычисленными координатами (X, Y) начала
               всех влезаемых в дисплей строк"""

            x, y = self._first_line_coord
            d: dict = dict()
            for i in range(1, self._max_lines+1):
                d[i] = (x, y)
                y += self._size_char + self._line_height
            return d
        
        
        def write(self, wtext: str, line: int) -> None:
            """Записать текст по номеру строки line.
               Создаются строки как svg объекты."""

            try:
                if (1 <= line <= self._max_lines):
                    crdX, crdY = self._lines_coords[line]

                        # если такой номер строки существует, то чистим ее и создаем новую.
                    if line in self._svg_lines:
                        self.clean(line)

                    svgNS = "http://www.w3.org/2000/svg"
                    newline = document.createElementNS(svgNS, "text")
                    newline.setAttributeNS(None, "id", f"{line}-line")
                    newline.setAttributeNS(None, "style", f"fill: rgb(51, 51, 51); font-family: monospace; font-size: {self._size_char}px;")
                    newline.setAttributeNS(None, "x", f"{crdX}")
                    newline.setAttributeNS(None, "y", f"{crdY}")

                        # если длинна строки больше максимально допустимой, то записываю только часть строки == макс. длинны
                    newline.textContent = wtext if (0 < len(wtext) <= self._max_len) else wtext[: self._max_len]       
                    
                    self._id_lcd.appendChild(newline)
                    self._svg_lines[line] = newline
                else:
                    raise ValueError("Не корректный номер строки. Ошибка.")
            except ValueError as ve:
                print(ve)
            except TypeError as te:
                print("Ошибка, не числовое значение line", te)



        def clean(self, line=None) -> None:
            """Очистка экрана. если вызвать метод без параметров
               то чистится все табло. """

            if line is None:
                if self._svg_lines:
                    for k, v in self._svg_lines.items():
                        self._id_lcd.removeChild(v)
                    self._svg_lines.clear()
            else:
                self._id_lcd.removeChild(self._svg_lines[line])



        def __get_coords_first_line(self) -> tuple:
            """Возвращает координаты первой строки с 
               учетом высоты символа  и межстрочного интевала"""

            return (self._x+5, self._y+self._size_char+self._line_height)
    </code></pre>
    <p>
        В конструктор передается строка  <span class="bld">id </span>SVG прямоугольника дисплея, размер символа (размер шрифта) <span class="bld">size_char: int</span> и параметр по умолчанию <span class="bld">line_height=2</span> интервал между строками.
        Вызывается конструктор суперкласса явно (хотя можно было и не писать). 
    </p>
    <p>После создания атрибутов <span class="bld">self._id_lcd, self._size_char,  self._line_height</span> в цикле <b>for</b>
        "расчехляется" Javascript SVGRect объект преобразованный в словарь на key:value  (key:str, value:int). Brython легко преобразует Javascript объекты в python словари. Вот как выглядит выражение 
        <pre><code class="python">
            . . .

            print(self._id_lcd.getBBox())
            for name_attr, value_attr in dict(self._id_lcd.getBBox()).items():
                super().__setattr__("_" + name_attr, value_attr)
            
            . . .   

        # ------------------------------------------------------------------------
            console: >> Javascript SVGRect object: [object SVGRect]
        # ------------------------------------------------------------------------

        # А после этого вывод будет таким:
            print(dict(self._id_lcd.getBBox()))

        # ------------------------------------------------------------------------
            console: >> {'x': 190, 'y': 33, 'width': 180, 'height': 125}
        # ------------------------------------------------------------------------
        </code></pre>
    <span class="bld">getBBox()</span>  - это webAPI метод. Из официальной <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox">документации:</a>
    </p>
    <p>
        <i>
            Метод <b>SVGGraphicsElement.getBBox()</b> позволяет определить координаты наименьшего прямоугольника, в который помещается объект. Возвращаемые координаты относятся к текущему пространству SVG (после применения всех атрибутов геометрии ко всем элементам, содержащимся в целевом элементе).
            getBBox() должен возвращать фактическую ограничивающую рамку во время вызова метода, даже если элемент еще не отрисован. Он также не учитывает какие-либо преобразования, примененные к элементу или его родителям. 
            getBBox возвращает значения, отличные от <u>getBoundingClientRect()</u>, так как последний возвращает значение относительно области просмотра. 
        </i>
    </p>  
    В общем этот метод вернул нам координаты и размеры нашего svg прямоугольника-дисплея и в цикле мы устанавливаем эти размеры и координаты через объект-делегат (вызов <span class="bld">super().__setattr__(name: str, value: Any)</span>)как атрибуты текущему экземпляру класса. Ко всем именам атрибутов добавляется символ нижнего подчеркивания.
    В итоге так выглядит <span class="bld">self.__dict__</span> 
    <pre><code class="python">
        for name_attr, value_attr in dict(self._id_lcd.getBBox()).items():
            super().__setattr__("_" + name_attr, value_attr)

        print(self.__dict__)


        # --------------------------------------------------------------------------------------
            console: >> {'_mega': None, '_id_lcd': SVGGElement id="lcd", '_size_char': 12, 
                         '_line_height': 2, '_x': 190, '_y': 33, '_width': 180, '_height': 125}
        # --------------------------------------------------------------------------------------
    </code></pre>
    Можно было написать так: <span class="bld">self.__dict__.update(dict(self._id_lcd.getBBox()))</span>, но мне нужны "защищенные" атрибуты, поэтому цикл с корректировкой имен атрибутов.
    <p>
        Создаем атрибут <span class="bld">self._first_line_coord: tuple</span> кортеж X Y коррдинат первой строки дисплея вверху слева. Атрибуту присваивается результат вызова метода 
        <span class="bld">__get_coords_first_line()</span>. Метод возвращает кортеж координат <span class="bld">X</span> => |координата <b>x</b> верхнего левого угла svg прямоугольника-дисплея (self._x) + ширина обводки 3px + 2 px отступ|, <span class="bld">Y</span> => |координата <b>y</b> верхнего левого угла svg прямоугольника-дисплея (self._y) + высота символа (размер шрифта аргумент конструктора) + значение межстрочного интервала (аргумент конструктора)|.
        <u>Для оси Y положительное направление в системе координат SVG - сверху вниз.</u>
    </p>
    <p>
        <span class="bld">self._max_lines: int</span> - Максимальное количество строк влезаемых в дисплей. Расчитывается на месте путем деления нацело высоты <b>height</b> изображения svg прямоугольника-дисплея (self._height) на сумму размера символа со значением межстрочного интервала (аргументы конструктора. Межстрочный интервал - именованый параметр=2).
    </p>
    <p>
        <span class="bld">self._lines_coords: dict</span> - Атрибут словарь для хранения кортежа координат XY строк внутри дисплея. Смысл в том, что координаты X начала всех строк не изменяются с момента создания svg объекта, а координаты Y каждой строки изменяются при добавлении на дисплей (первая строка это y1 px, третья строка это y1+k px k-(межстрочный интервал + размер символа) * номер строки).
        Короче координаты эти мне нужны чтобы знать куда позиционировать SVG объекты-строки указывая номер строки дисплея (в словаре в качестве ключей номера строк на дисплее от 1 до n).
        Словарь собирается на месте вызовом приватного метода <span class="bld">self.__get_lines_coords()</span>
    </p>
    <pre><code class="python">
        def __get_lines_coords(self) -> dict:
            """Возвращает словарь с вычисленными координатами (X, Y) начала
               всех влезаемых в дисплей строк"""

            x, y = self._first_line_coord
            d: dict = dict()
            for i in range(1, self._max_lines+1):
                d[i] = (x, y)
                y += self._size_char + self._line_height
            return d
    </code></pre>
    <p>
        Распаковываем в локальные переменные <span class="bld">x y</span> атрибут-кортеж координат первой строки дисплея.
        Создаем локальный пустой словарь результата. <b>d: dict</b>
        В цикле начиная [с 1 до значения макс. количества строк] добавляем в локальный словарь <b>d: dict</b> кортеж с одной и той же координатой <span class="bld">x</span>, а <span class="bld">y</span> координата на каждой итерации "самосуммируется" с (размером символа + межстрочный интервал). 
        Ключи словаря номера строк. Возврат словаря <b>d: dict</b>
    </p>
    <p>
        <span class="bld">self._max_len: int</span> - Длинна строки расчивывается как ширина дисплея + значение нулевого индекса (X координата) атрибута кортежа координат первой строки (а эта координата в свою очередь расчитана как self._x+5) нацело деленное на размер символа + 4 (4 и 5 - отступы).
    </p>
    <p>
        В этом классе 2 "боевых" метода - записать текст по номеру строки <span class="bld">write(self, какой-то текст: str, № строки дисплея: int)</span> и удалить строку по номеру/очистить дисплей <span class="bld">clean(self, line=None)</span>. Я посмел написать метод выполняющий больше одной задачи ай-яй-яй...
    </p>
    <pre><code class="python">
        def write(self, wtext: str, line: int) -> None:
            """Записать текст по номеру строки line.
               Создаются строки как svg объекты."""

            try:
                if (1 <= line <= self._max_lines):
                    crdX, crdY = self._lines_coords[line]

                        # если такой номер строки существует, то чистим ее и создаем новую.
                    if line in self._svg_lines:
                        self.clean(line)

                    svgNS = "http://www.w3.org/2000/svg"
                    newline = document.createElementNS(svgNS, "text")
                    newline.setAttributeNS(None, "id", f"{line}-line")
                    newline.setAttributeNS(None, "style", f"fill: rgb(51, 51, 51); font-family: monospace; font-size: {self._size_char}px;")
                    newline.setAttributeNS(None, "x", f"{crdX}")
                    newline.setAttributeNS(None, "y", f"{crdY}")

                        # если длинна строки больше максимально допустимой, то записываю только часть строки == макс. длинны
                    newline.textContent = wtext if (0 < len(wtext) <= self._max_len) else wtext[: self._max_len]       
                    
                    self._id_lcd.appendChild(newline)
                    self._svg_lines[line] = newline
                else:
                    raise ValueError("Не корректный номер строки. Ошибка.")
            except ValueError as ve:
                print(ve)
            except TypeError as te:
                print("Ошибка, не числовое значение line", te)
    </code></pre>
    <p>
        Параметры: <b>wtext</b> - (write text да простит меня Бог за мой английский и способность давать кодовым переменным имена) текст который нужно вывести на дисплее на строке номер <b>line</b>.
    </p>
    <p>
        В блоке трай первым делом проверяем, что переданный методу номер строки лежит в диапазоне [1, макс. кол-во строк в дисплее], если нет то выбрасываем исключение <span class="bld">raise ValueError("Не корректный номер строки. Ошибка.")</span> и продолжаем работать с пустым дисплеем.
        Если все нормально, то проверяем есть ли в словаре <span class="bld">self._svg_lines</span> ключ с таким номером строки. К слову этот атрибут-словарь хранит объекты svg-текст созданные в этом методе в качестве значений, а ключи - номера строк.
        Если в словаре присутствует ключ с таким номером, то это значит что на строке с этим номером напечатана текстовая информация (создан svg объект), поэтому удаляем svg объект с этим номером строки вызвав метод <span class="bld">self.clean(номер строки для удаления)</span> и создаем новый svg-текст объект <b>newline</b> на этом месте.
    </p>
    <p>
          webAPI метод <span class="bld">document.createElementNS(svgNS, "text")</span> создает собственно svg объект.
        webAPI метод <span class="bld">setAttributeNS</span> добавляет атрибуты svg объекту.
        webAPI метод <span class="bld">textContent</span> записывает текст в объект. Работает как <span class="bld">innerHTML</span>, но только для SVG.
        Тернарный оператор <b>wtext if (0 < len(wtext) <= self._max_len) else wtext[: self._max_len]</b> - записать строку текста <span class="bld">wtext</span> если длинна строки строго больше нуля и меньше или равно длинны строки дисплея, в противном случае записать срез строки от начала текстовой строки до значения максимальной длины строки дисплея. Короче если мы хотим вывести слишком длинную строку, то выведется обрезанная строка до правой границы дисплея.
        webAPI метод <span class="bld">self._id_lcd.appendChild(newline)</span> равносильно <span class="bld">document["lcd"].appendChild(newline)</span> добавляет наш svg объект в структуру svg разметки.
    </p>
    <p style="color: rgba(197, 21, 21, 0.87);">
        <b><i>SVG текст должен быть создан в группе (тег g) например: document["id группы g"].appendChild(объект с добавленными атрибутами). Иначе он не будет виден.</i></b>
    </p>
    <p>
        И наконец <span class="bld">self._svg_lines[line] = newline</span> добавляем созданный объект svg текста в словарь (временно прописываем его в общежитии).
    </p>

    </div>
    </section>   

     <!-- <pre><code class="python">
        
        </code></pre>
        <p>Задает во всех объектaх модулей объект чипа ATMega. [mega = None]"""</p> 
        <span class="bld"></span>     -->
    
    <script type="text/python">

    from browser import document, window, html, bind, timer
    from typing import Any, Callable, Generator
    from functools import wraps
    import time
    import math



    # ----------------------------------------- ID графических штук ----------------------------------------------------------------------------------------
    #
    # id мотор-редуктора:   ["val"] - вал (с синим оттенком на редукторе) со шнопочным пазом
    #                       ["limb"] - меняет цвет на зеленый когда мотор работает. На рисунке - похож на сальник вокруг вала
    # id енкодера:          ["encoder"] - <g> колесо енкодера со всеми графическими дополнениями. Ручка, которую надо крутить для настройки.
    #                       ["encoder-svg"] - контур path фигуры колеса енкодера. Использую для перекрашивая контура при наведении мышкой
    # id lcd дисплея:       ["lcd"] - прямоугольник похожий на дисплей. Группа <g>
    #                               xk, yk - координаты строк. где k номер строки:
    #                                   (x1=195, y1=50), (x2=195, y2=64), (x3=195, y2=78), (x4=195, y4=92),
    #                                   (x5=195, y5=106), (x6=195, y6=120), (x7=195, y7=134), (x8=195, y8=148)
    #                       как видно координаты x начала строки - 195px относительно границы viewBox, а
    #                       y(высота) от начала (1 строчки) 50px и через каждые 14px (размер шрифта + 2px для разделения строк)
    #                       до последней 8 строчки 148px. Длинна строки - 23 символа. Почему так? Хрен его знает. Так нарисовал. Для демонстрации пойдет.
    #                 
    # id кнопок:            ["power-on"] - зеленая. Включить питание.
    #                       ["power-off"] - красная. Откл. питание. Стоп
    #                       ["encoder"] - кнопка колесика мыши. Работает с событием "mousedown". Номер кнопки = 2
    #                       ["man-mode"] - ручной режим. работает как флаг
    #
    # id руки ручн. режима: ["hand-push"] - <g> рука + текст + полумесяц
    #                       ["lamp-push"] - полумесяц
    #                       ["text-hand-push"] - текст
    #
    #
    # ---------------------------------------------------------------------------------------------------------------------------------------------------------


    class Component:
        """Базовый класс всех компонентов.
           Задает во всех объектaх модулей объект чипа ATMega. [mega = None]"""

        def __init__(self) -> None:
            self._mega = None

        @property
        def mega(self):
            return self._mega

        @mega.setter
        def mega(self, obj) -> None:
            self._mega = obj
      


    class Display(Component):
        '''Родительский класс дисплея. Делает закулисную грязную работу. Будет по id svg объекта
           вычислять атрибуты: число строк, длинна строки, координаты начала строки
           размеры дисплея...'''

        
        def __init__(self, id_svg: str, size_char: int, line_height=2) -> None:
            super().__init__()
            
                # объект svg <g> дисплея
            self._id_lcd = document[id_svg]

                # размер шрифта (высота символа) в пикселях. т-е число int это размер в пикселях.
            self._size_char = size_char

                # межстрочный интервал px
            self._line_height = line_height
            
                # cоздаю атрибуты из полученных данных от getBBox():
                # self._x, self._y -- координаты фигуры 
                # self._width, self._height -- ширина, высота фигуры

            for name_attr, value_attr in dict(self._id_lcd.getBBox()).items():
                super().__setattr__("_" + name_attr, value_attr)

                # координаты первой строки
            self._first_line_coord: tuple = self.__get_coords_first_line()

                # макс. число строк с учетом высоты символа + межстрочного интевала
            self._max_lines: int = self._height // (self._size_char+self._line_height)

                # словарь [№строки : координата Y]
            self._lines_coords: dict = self.__get_lines_coords()
                
                # словарь обЪектов строк. Строки добавляются в write()
            self._svg_lines: dict = dict()

                # макс. длинна строки (символов). 4 - от балды взято (на самом деле с 4 расчет более-менее правильный)
            self._max_len: int = (self._width + self._first_line_coord[0]) // (self._size_char + 4)
            

        # ---------------------------------------------------------------------------------------------------

        def __get_lines_coords(self) -> dict:
            """Возвращает словарь с вычисленными координатами (X, Y) начала
               всех влезаемых в дисплей строк"""

            x, y = self._first_line_coord
            d: dict = dict()
            for i in range(1, self._max_lines+1):
                d[i] = (x, y)
                y += self._size_char + self._line_height
            return d
        
        
        def write(self, wtext: str, line: int) -> None:
            """Записать текст по номеру строки line.
               Создаются строки как svg объекты."""

            try:
                if (1 <= line <= self._max_lines):
                    crdX, crdY = self._lines_coords[line]

                        # если такой номер строки существует, то чистим ее и создаем новую.
                    if line in self._svg_lines:
                        self.clean(line)

                    svgNS = "http://www.w3.org/2000/svg"
                    newline = document.createElementNS(svgNS, "text")
                    newline.setAttributeNS(None, "id", f"{line}-line")
                    newline.setAttributeNS(None, "style", f"fill: rgb(51, 51, 51); font-family: monospace; font-size: {self._size_char}px;")
                    newline.setAttributeNS(None, "x", f"{crdX}")
                    newline.setAttributeNS(None, "y", f"{crdY}")

                        # если длинна строки больше максимально допустимой, то записываю только часть строки == макс. длинны
                    newline.textContent = wtext if (0 < len(wtext) <= self._max_len) else wtext[: self._max_len]       
                    
                    self._id_lcd.appendChild(newline)
                    self._svg_lines[line] = newline
                else:
                    raise ValueError("Не корректный номер строки. Ошибка.")
            except ValueError as ve:
                print(ve)
            except TypeError as te:
                print("Ошибка, не числовое значение line", te)



        def clean(self, line=None) -> None:
            """Очистка экрана. если вызвать метод без параметров
               то чистится все табло. """

            if line is None:
                if self._svg_lines:
                    for k, v in self._svg_lines.items():
                        self._id_lcd.removeChild(v)
                    self._svg_lines.clear()
            else:
                self._id_lcd.removeChild(self._svg_lines[line])



        def __get_coords_first_line(self) -> tuple:
            """Возвращает координаты первой строки с 
               учетом высоты символа  и межстрочного интевала"""

            return (self._x+5, self._y+self._size_char+self._line_height)

        # ---------------------------------------------------------------------------------------------------------

    class Lcd(Display):
        """Дисплей"""

        def __init__(self, id_svg: str, size_char: int) -> None:
            """2 параметра: айди грфического объекта группы <g> - id_svg; 
                            размер шрифта - size_char"""

            super().__init__(id_svg, size_char)
            self.on_power()

            
        @property
        def id(self):
            """объект svg дисплея. Возвращает объект прямоугольника в группе <g id="lcd">"""
            return self._id_lcd.firstElementChild

        @id.setter
        def id(self, value: Any):
            """Не изменяемый"""
            pass

        @property
        def strlen(self) -> int:
            return self._max_len

        @property
        def maxlines(self) -> int:
            return  self._max_lines


        def on_power(self) -> None:
            """Включить питание. Цвет дисплея светло зелено-серый"""

            self.id.style["fill"] = f"rgb(203, 240, 143)"



        def off_power(self) -> None:
            """Отключить питание. Стереть всё."""

            self.id.style["fill"] = f"rgb(158, 182, 121)"
            self.clean()



        # --------------------------------------------------------------------------------------------------------------

    class Encoder(Component):
        """Ручной енкодер"""

        def __init__(self, id_encoder: str, id_encoder_path: str) -> None:
            """id_encoder - айди группы <g> svg объекта; id_encoder_path - айди обводки колесика (paht)"""

            super().__init__()

                # объект группы енкодера
            self._id = document[id_encoder]

                # <path>. Hужна его обводка для выделения при наведении мыши
            self._path_id = document[id_encoder_path]

                # на сколько градусов повернуть за раз енкодер 
            self._deg_step = 10
                
                # сумма поворотов
            self._total_deg = 0

                # направление вращения: 1 туда, -1 сюда
            self.around_direction: int = 1

                # Имя браузера (не понадобилось. Оставил на память для что-как-куда)
            self.navigator: list = window.navigator.userAgent.split("/")[2].split()[-1]

                # обработчики событий прокрутки колесика мыши над енкодером для браузеров Firefox и группы v8 
            self._id.bind("mousewheel", self.wheel)
                # Этот для Firefox
            self._id.bind("DOMMouseScroll", self.wheel) 

                # Обработчик события по наведении указателя мыши на енкодер
            self._id.bind("mouseover", self.select_encoder)

                # Обработчик события если убрать указатель мыши из области енкодера
            self._id.bind("mouseout", self.no_select_encoder)

                # Обработчик события при нажатия на колесико мыши на енкодер.
            self._id.bind("mousedown", self.click_wheel)
            


        @property
        def deg_step(self) -> int:
            """Вернуть шаг поворота"""

            return self._deg_step


        @deg_step.setter
        def deg_step(self, value: int) -> None:
            self._deg_step = value


        @property
        def total_deg(self) -> int:
            """Геттер вернет общее кол-во поворотов енкодера."""

            return self._total_deg


        @total_deg.setter
        def total_deg(self, value: int) -> None:
            self._total_deg = value
        

        def wheel(self, e) -> None:
            """wheelDelta - группа браузеров v8, detail - мозилла.
               если событие пришло от браузеров группы v8 то значение
               вернувшее wheelDelta (120) изменяем на 1 поделив его на 120. 
               detail есть в мозилле и он вернет или -1 или 1. В зависимости 
               от браузера в любом случае значение объекта события нужно сделать равным 1
               и умножить на наш шаг-градусы разовой прокрутки енкодера. Код честно спер с какого-то
               сайта про javascript."""

            delta = None
            if hasattr(e, "wheelDelta"):
                delta = e.wheelDelta / 120
                self.total_deg += delta * (-self.deg_step)
    
            elif hasattr(e, "detail"):
                delta = e.detail / 3
                self.total_deg += delta * (-self.deg_step)
                
            if delta:
                    # сохранить знак направления вращения, запретить прокрутку над svg объектом
                self.around_direction = 1 if delta > 0 else -1
                e.preventDefault()

                if abs(self.total_deg) >= 360:
                    self.total_deg = 0
            self._id.attrs["transform"] = f"rotate({self.total_deg})"  

            self.mega.wheel_method() 
            
            

        def select_encoder(self, e) -> None:
            """Сменить цвет обводки на красный при наведении указателя
               мыши на енкодер."""
            document.querySelector("body").style["cursor"] = "move"
            self._path_id.style = "stroke: red; stroke-width: 4px; fill: url(#gradient-10)"



        def no_select_encoder(self, e) -> None:
            """Вернуть черный оттенок если убрать указатель мыши
               из области фигуры енкодера."""
            document.querySelector("body").style["cursor"] = "default"
            self._path_id.style = "stroke: rgb(0, 0, 0); fill: url(#gradient-10)"



        def click_wheel(self, e) -> None:
            """При нажатии колесика мыши меняется масштаб фигуры
                енкодера, и через короткое время вызывается встроенная
                ф-ция, которая изменяет масштаб в нормальное значение."""

            def reset():
                self._id.attrs["transform"] = f"scale(1), rotate({self.total_deg})"

            if e.which == 2:
                self._id.attrs["transform"] = f"scale(0.98), rotate({self.total_deg})"
                timer.set_timeout(reset, 150)
                
                self.mega.push_wheel_method() 
                

    # -----------------------------------------------------------------------------------------------------------

    class Motor(Component):
        """Мотор-редуктор"""

        svg_attrs_point: tuple = ("id", "cx", "cy", "r")
        svg_attrs_text: tuple = ("id", "x", "y")
        svg_attrs_line: tuple = ("id", "x1", "y1", "x2", "y2")            
        

        def __init__(self, id_val: str, id_limb: str) -> None:
            super().__init__()

                # объект вала
            self._id = document[id_val]

                # оъект круглой толстой штуки вогруг синего вала
            self._limb = document[id_limb]

                # на сколько градусов провернут вал
            self._total_d: float = 0

                # намеченные точки вокруг вала
            self.points: dict = dict()
                
                # объекты текста (числа в градусах возле точек)
            self.text_deg_point: list = list()

                # g группа для точек
            self.gservo = document["servo"]
            self.arrow_line = None
            
        # ------------------------------------------------------------------------------
        
        def create_points(self) -> None:
            """Нарисовать точки-окружности после команды ДА равномерная разметка или не равномерная разметка.
               Значения углов берется из уже заполненного в одном из состояний списка self.mega.groupdegs.
               Также рисуется линия-указатель и текст число градусов возле точки. С позиции относительный нуль справа."""

            cx = float(self.limb["cx"])
            cy = float(self.limb["cy"])
            
            deg_pos = self.mega.degpos
            tmp_deg = 0
            radius = int(self.limb["r"])+15

            def make_text_deg(value, *args):
                """Текст угол волзе точки
                параметры value: int *args =  id: str, crdX: int, crdY: int, """

                svgNS = "http://www.w3.org/2000/svg"
                label_point = document.createElementNS(svgNS, "text")
                for attribute in map(lambda x, y: (None, x, y), self.svg_attrs_text, args):
                    label_point.setAttributeNS(*attribute)
                label_point.setAttributeNS(None, "style", f"fill: black; font-family: monospace; font-size: {5}px;")
                label_point.textContent = f"{int(value)}\u00B0"
                self.text_deg_point.append(label_point)
                return label_point


            def make_point(*args):
                """Создать точки вокруг вала.
                   *args = id: str, posX: int, posY: int, radius: float"""

                svgNS = "http://www.w3.org/2000/svg"
                point =  document.createElementNS(svgNS,"circle")
                for attribute in map(lambda x, y: (None, x, y), self.svg_attrs_point, args):
                    point.setAttributeNS(*attribute)
                point.setAttributeNS(None, "fill", "rgba(137, 17, 173, 0.7)")
                return point


            def make_line(*args):
                """Линия-указатель от центра вала до точки.
                args = id: str, cx: float, cy: float, posx, posy"""

                
                svgNS = "http://www.w3.org/2000/svg"
                ln = document.createElementNS(svgNS,"line")
                for attribute in map(lambda x, y: (None, x, y), self.svg_attrs_line, args):
                    ln.setAttributeNS(*attribute) 
                ln.setAttributeNS(None, "stroke", "rgba(236, 35, 62, 0.815)")
                ln.setAttributeNS(None, "stroke-width", "2px")
                return ln


            for i, delta in enumerate(self.mega.groupdegs):
                key: str = "point-"+str(i)
                posX = cx + radius * math.cos(((tmp_deg ) * math.pi) / 180)
                posY = cy + radius * math.sin(((tmp_deg ) * math.pi) / 180)
                obj_point = make_point(key, posX, posY, 3) 
                obj_text_point = make_text_deg(tmp_deg, "text-"+key, posX+3, posY+2)
                self.gservo.appendChild(obj_point)
                self.gservo.appendChild(obj_text_point)
                    # ключ - номер пп, значение - объект
                self.points[i] = obj_point
                tmp_deg += delta
            
                # -deg_pos * math.pi для того чтобы после поворота вала 
                # (после отмены или ручного поворота, 2 круга программы) кружки и линия 
                # рисовалить с нулем справа посередине вала (на 90 град от верха по-людски). 
            posx_line = cx + radius * math.cos((-deg_pos * math.pi) / 180)
            posy_line = cy + radius * math.sin((-deg_pos * math.pi) / 180)
            obj_line = make_line("arrow-line", cx, cy, posx_line, posy_line)
            self.arrow_line = obj_line
            self.id.appendChild(obj_line)
                
        # ------------------------------------------------------------------------------
            
        def delete_points(self) -> None:
            """Удалить точки, значения угла и линию по 
               выходе из меню, конца программы."""

            if self.points:
                for key, val in self.points.items():
                    self.gservo.removeChild(val)
                self.points.clear()
                if self.arrow_line:
                    self.id.removeChild(self.arrow_line)
                if self.text_deg_point:
                    for txtp in self.text_deg_point:
                        self.gservo.removeChild(txtp)    
                self.text_deg_point.clear()


        def null_position(self) -> None:
            """обнулить позицию вала"""
            self._total_d = 0
            self.id.attrs["transform"] = f"rotate(0)"



        @property
        def id(self):
            return self._id

        @id.setter
        def id(self, value) -> None:
            pass


        @property
        def limb(self):
            return self._limb

        @limb.setter
        def limb(self, value) -> None:
            pass

        
        @property
        def degstep(self) -> int:
            return self._total_d

        @degstep.setter
        def degstep(self, value) -> None:
            
            self._total_d += float(value)
            if self._total_d >= 360:
                self._total_d = 0
            
            self.id.attrs["transform"] = f"rotate({self._total_d})"

    # --------------------- функции-декораторы для class ATMega----------------------------------------------------
    
    def inject(method_setter: Callable) -> Callable:
        """Декоратор для сеттеров. Внедряет объект ATMega в объект каждой компоненты
            до присваивания соотв. атрибута экземпляра ATMega. """
        
        @wraps(method_setter)
        def wrapper(self, obj) -> None:
            obj.mega = self
            method_setter(self, obj)
            
        return wrapper



    def substitute_wheel(deco_method: Callable) -> Callable:
        """Декоратор для устранения дубл кода. Используется в методах обрабоки событий вращения 
           колеса мыши, когда нажали на поле ввода для редактирования в меню настроек."""

        @wraps(deco_method)
        def wrapper(self):
            deco_method(self)

            # сохраняю ссылку на метод (который по умолчанию) нажатии колесика мыши 
            self.stackpush = self.displays[self.enum_state.get(self.state)]["field"][self.nav][1]
                # теперь этому полю подменяю метод по следующему нажатию
            self.displays[self.enum_state.get(self.state)]["field"][self.nav][1] = self.apply
                # запрет навигации. только больше-меньше значения параметра при вращении колеса мыши
            self.displays[self.enum_state.get(self.state)]["navigate"] = False

        return wrapper

        


    class ATMega:
        """Ардуина. Чип: 8-bit Atmel ATmega2560.
           Модель классов напоминает паттерн 'Посредник', 
           только без интерфейса. Этот в роли посредника."""

        def __init__(self, lcd: Lcd, encoder: Encoder, motor: Motor) -> None:
            self.lcd = lcd
            self.encoder = encoder
            self.motor = motor
            self.lamp_man_mode = document["lamp-push"]
            self.text_man_mode = document["text-hand-push"]

                # хранит позицию выделенного пункта меню
            self.nav = 1

                # сохраняет ссылку на метод события нажатия колесика перед экзекуцией
            self.stackpush = None

                # хранит строки дисплея текущего состояния
            self.map_display: list = list()
                
                # состояние. начальное состояние = 'BEGIN'
            self._state = 6

                # подсостояния в макросостоянии RUN_AUTO
            self._substate = 0

                # генератор разбитых по окружности значений углов
            self.deggen = None

                # счетчик таймера. Для мигания выбранного поля ввода.
            self.blink: int = 0
                
                # таймер
            self.timer = time.time()

                # флаг ручной режим. Для поворота вала енкодером 
            self.is_man_mode: bool = False
                
                # флаг разрешения ручного режима
            # self.is_push_man_mode: bool = False

                # метод вызываемый при прокрутки колеса мыши
            self.wheel_method: Callable = self.round_wheel

                # метод вызываемый при нажатии на колесо мыши
            self.push_wheel_method: Callable = self.button_wheel
            
            # ---------------- атрибуты устройства ---------------------
                # передаточное число
            self._delta_reductor: float = 1.0

                # скорость в режиме разметки
            self._vauto: float = 0.8

                # скорость в ручном режиме
            self._vman: int = 1

                # угол между метками
            self. _set_deg: float = 45.0

                # разбить на равное кол-во частей?
            self.is_equally: bool = True

                # количество меток равномерная разметка
            self._amount: int = 8

                # количество меток не равномерная разметка
            self._amount_not_eq: int = 4

                # итого в сумме при равномерной разметке
            self._totalsum: float = 45.0

                # массив (список) для задания значений не равномерной и равномерной разметки.
                # в меню неравном. разметка заполняем как есть например [20,20,20,45]. в сумме должно быть <= 360
            self.groupdegs: list = list()

                # текущий угол поворота
            self.degpos: float = 0
                           
                # значение градусов, до которого нужно провернуть сейчас
            self._next_point: float = 0.0

                # количество шагов (от точки до точки)
            self.total_point = 0

                # счетчик точек
            self.counter_point = 0

                # константы макро состояний
            self.enum_state: dict = {
                None: "END", 1: "EQUALLY", 2: "SETTING", 11: "NOT_EQUALLY", 44: "PREPARE_NOT_AM", 4: "PREPARE_AM", 5: "RUN_AUTO", 6: "BEGIN", 7: "STOP"
            }

                # константы микросостояний в режиме работы авто
            self.enum_microstate: dict = {
                0: "mSTOP", 1: "mGET_CORO", 2: "mNEXT_POINT", 3: "mROTATE", 4: "mPOINT",  5: "mPAUSE", 6: "mCONTINUE"
            }

                # дисплеи состояний, пункты меню, замещающие ссылки методов на события вращения и нажатия колеса мыши 
            self.displays: dict = { 
                "BEGIN":{"nav":{1: ["да", self.st_mtd_yes], 2: ["настр.", self.st_mtd_settings], 3: ["нет", self.st_mtd_no]},
                         "field": dict(),
                         "text": {2: f"{'\u00A0'*6}"+"равномерная", 3: f"{'\u00A0'*7}"+"разметка?"},
                         "navigate": True
                         
                },
                "SETTING":{"nav":{1: ["да", self.st_mtd_sett_yes]},
                            "field":{2: [f"передат. число:", self.set_dreductor, self._delta_reductor], 3: [f"скорость авто:", self.set_vauto, self._vauto],
                                    4: [f"скорость ручн.:", self.set_vman, self._vman]},
                            "text": {1: f"{'\u00A0'*2}"+"ГЛОБАЛЬНЫЕ"+f"{'\u00A0'}"+"НАСТРОЙКИ"},
                            "navigate": True
                },
                "EQUALLY": {"nav":{1: ["да", self.st_mtd_equal_yes]},
                            "field": {2: [f"количество:", self.set_amount, self._amount], 3: [f"градусов:", self.empty_method, self._totalsum]},
                            "text": {1: f"{'\u00A0'*2}"+"РАЗМЕТКА ПОРОВНУ"},
                            "navigate": True
                },
                "NOT_EQUALLY": {"nav": {1: ["добавить", self.add_not_equal]},
                               "field": {2: [f"число точек:", self.set_amount_not_eq, self._amount_not_eq]},
                               "text": {1: f"НЕ РАВНОМЕРНАЯ РАЗМЕТКА"},
                               "navigate": True
                },
                "PREPARE_AM": {"nav": {1: ["начать", self.start_head], 2: ["отмена", self.stop_head]},
                            "field": dict(),
                            "text": {1: f"\u00A0 РАВНОМЕРНАЯ РАЗМЕТКА"},
                            "navigate": True
                },
                "PREPARE_NOT_AM": {"nav": {1: ["да", self.start_head], 2: ["отмена", self.stop_head]},
                            "field": dict(),
                            "text": {1: f"ДИАПАЗОНЫ:"},
                            "navigate": True
                },
                "RUN_AUTO": {"nav": {1: ["продолжить", self.continue_head], 2: ["отмена", self.cancel]},
                            "field": dict(),
                            "text": {1: "В РАБОТЕ!"},
                            "navigate": True
                },
                "STOP": {"nav": {1: ["в начало", self.stop_head]},
                         "field": dict(),
                         "text": {2: f"{'\u00A0'*9} СТОП"},
                         "navigate": True
                }
            }
           
        # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 

        def run(self) -> None:
            """Пуск машины состояний."""

            s = self.enum_state.get(self.state)
            if not s:
                self.state = 6

                # (dsp - display) дисплей (один из вложенных словарей self.displays) текущего состояния
            dsp: dict = self.displays[s]

                # для моргания значения пункта поля ввода в меню настроек
            if (time.time() - self.timer) >= 0.3:
                self.blink += 1
                self.timer = time.time()
                if self.blink >= 255:
                    self.blink = 0
            
                # очистка и наполнение при каждом вызове атрибута-словаря пунктами меню 
                # (строка навигации и если есть поля ввода) текущего дисплея состояния.
            self.map_display.clear()
            self.map_display.extend([dsp["nav"], dsp["field"]])

                # проверка что мы сейчас не редактируем параметры настроек. Только для колесика мыши.
            if dsp["navigate"]:
                    # замещение метода события вращения колеса
                self.wheel_method = self.st_mtd_wheel

                # замещение метода события нажатия колесика мыши по пунктам меню
            self.push_wheel_method = self.get_deploy_map_display()[self.nav][1]
            

            # --------------------------------> BEGIN state
            
            if s == "BEGIN":
                self.manual_mode()
                    # текст на табло
                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                    # получить строку навигации и полей ввода (если есть)
                navigate, field_sett = self.get_nav(s) 
               
                    # вывести меню на экран
                self.lcd.write(navigate, 8)
                mode = f"положение: {round(self.degpos, 4)}\u00B0"
                self.lcd.write(mode, 5)

            # --------------------------------> SETTING state   
            elif s == "SETTING":

                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                navigate, field_sett = self.get_nav(s)
                
                    # вывести меню на экран
                self.lcd.write(navigate, 8) 
                
                    # вывод полей ввода и значений на экран
                for i, line in enumerate(field_sett):
                    self.lcd.write(line, i+3)

            # --------------------------------> EQUALLY state 
            elif s == "EQUALLY":
                
                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                navigate, field_sett = self.get_nav(s)
                    # вывести меню на экран
                self.lcd.write(navigate, 8) 
                for i, line in enumerate(field_sett):
                    self.lcd.write(line, i+3)

            # --------------------------------> NOT_EQUALLY state
            elif s == "NOT_EQUALLY":

                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                navigate, field_sett = self.get_nav(s)
                    # вывести меню на экран
                self.lcd.write(navigate, 8) 
                for i, line in enumerate(field_sett):
                    self.lcd.write(line, i+3)


            # --------------------------------> PREPARE_AM state 
            elif s == "PREPARE_AM":
                
                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                navigate, field_sett = self.get_nav(s) 
                self.lcd.write(navigate, 8)
                mode = f"положение: {round(self.degpos, 4)}\u00B0"
                self.lcd.write(mode, 3)
                self.lcd.write(f"{'-' * self.lcd.strlen}", 4) 
                self.lcd.write(f"{'\u00A0'*3} на {self.amount}"+" штук", 5)
                self.lcd.write(f"{'\u00A0'*3} по {self.total_sum}"+"\u00B0", 6)

            # --------------------------------> PREPARE_NOT_AM state
            elif s == "PREPARE_NOT_AM":
                    # чистка дисплея, чтобы при скроллинге удалить 
                    # последние повторения
                self.lcd.clean()
                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                navigate, field_sett = self.get_nav(s)
                    # вывести меню на экран
                self.lcd.write(navigate, 8) 
                for i, line in enumerate(field_sett):
                    self.lcd.write(line, i+3)


            # --------------------------------> RUN_AUTO state
                        #
                        # 0: "mSTOP", 1: "mGET_CORO", 2: "mNEXT_POINT", 3: "mROTATE", 
                        # 4: "mPOINT"  5: "mPAUSE", 6: "mCONTINUE"
                        #
                        # self.deggen - объект-генератор
                        # self.nextpoint - очередное значение от генератора
                        # self.counter_point - счетчик пройденных точек. Ключи словаря объектов svg кружков-точек -- числа по порядку
                        # self.total_point - для определения одного оборота
                        # self.degpos - текущий угол поворота 

            elif s == "RUN_AUTO":
                   
            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~> substate: 1-mGET_CORO
                if self.substate == 1:
                        # получаю генератор списка градусов
                        # переход в подсостояние получения очередной точки от генератора 
                    self.deggen = self.next_deg()
                    self.substate = 2
                    
            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~> substate: 2-mNEXT_POINT
                elif self.substate == 2:
                    # получаю от генератора угол на который нужно провернуться
                    # в блоке трай ловлю СтопИтерейшн конца генератора, если генератор иссяк,
                    # то это конец программы и переход в подсостояние 0, потом в макросостояние STOP 
                    
                    try:
                        self.nextpoint = next(self.deggen)
                        self.degpos = 0.0
                        self.counter_point += 1
                        self.total_point += self.nextpoint

                        if self.total_point >= 360:
                            self.counter_point = 0

                            # взятие нового времени для отсчета
                        self.timer = time.time()
                        self.substate = 3
                        self.lcd.clean()
                    except StopIteration:
                        self.substate = 0

            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~> substate: 3-mROTATE
                elif self.substate == 3:
                    self.lcd.write("В РАБОТЕ", 2)
                    self.lcd.write(f"тек. положение: {round(self.degpos, 2)}", 5)

                        # по истечении малого промежутка времени прибавить в углу поворота значение выражения
                        # (скорость в авто режиме / передаточное число редуктора)
                        # такая анимация

                    if (time.time() - self.timer) >= 0.005:
                        speed: float = (self.vauto / self.delta_reductor)
                        self.motor.degstep = speed
                        self.degpos += speed
                        
                        # если находимся в пределах центра точки, то перекрашиваем точку в зеленый
                        # и это значит пауза. переходим в подсостояние ожидания нажатия на пункте меню, которое
                        # вызовет метод перевода в подсостояние № 2. И так по кругу, пока жив генератор.

                    if (self.nextpoint-0.5 <= self.degpos <= self.nextpoint+0.5):
                        self.motor.points[self.counter_point].style["fill"] = "rgb(0, 147, 49)"
                        self.lcd.clean()
                        self.substate = 4

            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~> substate: 4-mPOINT
                elif self.substate == 4:
                    
                    for k in dsp["text"]:
                        self.lcd.write(dsp["text"][k], k)
                    navigate, field_sett = self.get_nav(s)    
                    self.lcd.write(navigate, 8)
                    self.lcd.write(f"{'\u00A0'*9}ПАУЗА.", 4)

            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~> substate: 
                elif self.substate == 0:
                    self.state = 7
                    
                     
            # --------------------------------> STOP state       
            elif s == "STOP":
                self.lcd.clean()
                self.total_point = 0
                self.counter_point = 0

                self.degpos = self.get_value_rotate()

                self.nextpoint = 0
                self.deggen = None
                for k in dsp["text"]:
                    self.lcd.write(dsp["text"][k], k)

                navigate, field_sett = self.get_nav(s) 
                self.lcd.write(navigate, 8)               


                # void loop()
            window.setTimeout(self.run)




        def next_deg(self) -> Generator:
            """Вернет объект-генератор списка частей окружности."""

            if self.groupdegs:
                for value in self.groupdegs:
                    yield value


        def get_value_rotate(self) -> float:
            """Вернуть положение вала, положение отщемляем от атрибута transform (rotate) svg.
               Без этого не коpректно расчитываются координаты точек после 1-го
               прохода. Присваеваем возвр. значение self.degpos в теле elif state->STOP"""

            str_rotate: str = self.motor.id.attrs["transform"]
            deg = str_rotate[str_rotate.find('(')+1 : str_rotate.rfind(')')]
            return float(deg)

        # --------------------------------------------------------------------------------------------------

        def apply(self) -> None:
            """Применить после второго нажатия на колесо при редактировании. 
              Для всех работает одинаково (т-е индивидуальности не требуется)."""

            self.displays[self.enum_state.get(self.state)]["navigate"] = True
            self.displays[self.enum_state.get(self.state)]["field"][self.nav][1] = self.stackpush
            self.stackpush = None

            #print(self.displays["PREPARE_NOT_AM"]["field"])

        def change_delta_reductor(self) -> None:
            """ Инкремент-декремент значений при вращении колеса мыши на пункте поля ввода 
                передаточное число редуктора"""            
            self.delta_reductor += (self.encoder.around_direction / 2.0)


        def change_total_sum(self) -> None:
            """Инкремент-декремент значений при вращении колеса мыши на пункте поля ввода 
            градусы в меню равномерная разметка """

            self.total_sum += (self.encoder.around_direction / 2.0)



        def change_vauto(self) -> None:
            """настройки SETTING скорость в авторежиме
            СОБЫТИЯ ВРАЩЕНИЯ КОЛЕСА МЫШИ"""

            self.vauto += (self.encoder.around_direction / 10)



        def change_vman(self) -> None:
            """настройки SETTING скорость в ручн. режиме
               СОБЫТИЯ ВРАЩЕНИЯ КОЛЕСА МЫШИ. """

            self.vman += self.encoder.around_direction
           


        def rotate_val_man_mode(self) -> None:
            """Замененный метод на вращение колеса мыши. 
                Вращаем енкодер - вращается вал.
                rgba(137, 17, 173, 0.7) - син. rgb(0, 147, 49) - зел"""
            
            self.motor.degstep = self.encoder.around_direction * self.vman
            self.degpos = self.motor.degstep
            if self.degpos >= 360:
                self.degpos = 0
            elif self.degpos <= 0:
                self.degpos = 360-abs(self.motor.degstep)
            
                 
        
        def count_field_equally(self) -> None:
            """Вращение колеса мыши. РАВНОМЕРНАЯ РАЗМЕТКА."""
        
            self.amount += self.encoder.around_direction       
            try:
                x = 1 / self.amount    
            except ZeroDivisionError:
                self.amount = 1


        def count_field_not_equally(self) -> None:
            """Вращение колеса мыши. НЕ РАВНОМЕРНАЯ РАЗМЕТКА."""

            self.amount_not_eq += self.encoder.around_direction       
            try:
                x = 1 / self.amount_not_eq    
            except ZeroDivisionError:
                self.amount_not_eq = 1


        def change_range_not_equall(self) -> None:
            self.motor.delete_points()
            total = sum([i[2] for i in self.displays["PREPARE_NOT_AM"]["field"].values()])
            if self.this_param <= 0:
                self.this_param = 1
            elif total > 360:
                self.this_param -= 5
            else:
                self.this_param += self.encoder.around_direction
            for i, value in enumerate(self.displays["PREPARE_NOT_AM"]["field"].values()):
                self.groupdegs[i] = value[2]
            tmp_sum = sum(self.groupdegs[:-1])
            
            self.groupdegs[-1] = 360 - tmp_sum
            self.motor.create_points()
            
        # . . . . . . . . . --------------- . . . . . . . . . . . 

        def st_mtd_yes(self) -> None:
            """пункт меню ДА-главный экран. Событие по нажатии"""

            self.state = 1
            self.lcd.clean()
            self.nav = 1

        

        def st_mtd_settings(self) -> None:
            """пункт меню НАСТР.-главный экран. Событие по нажатии"""

            self.state = 2
            self.lcd.clean()
            self.nav = 1 



        def st_mtd_no(self) -> None:
            """пункт меню НЕТ-главный экран. Событие по нажатии"""

            self.state = 11
            self.lcd.clean()
            self.nav = 1




        def st_mtd_sett_yes(self) -> None:
            """пункт меню ДА-меню настройки. Событие по нажатии"""

            self.state = 6
            self.nav = 1
            self.lcd.clean()



        def st_mtd_equal_yes(self) -> None:
            """пункт меню ДА равномерная разметка"""
            self.state = 4
            self.nav = 1
            self.lcd.clean()
                      
                # добавление в self.groupdegs значений углов
            self.groupdegs.extend([self.total_sum for _ in range(self.amount)])
                # тут вызов рисовалки
            if self.groupdegs:
                self.motor.create_points()



        def add_not_equal(self) -> None:
            """пункт меню ДА не равномерная разметка"""           
            self.state = 44
            self.nav = 1
            self.lcd.clean()
            self.groupdegs.extend([20 for _ in range(self.amount_not_eq-1)])
            tmp_sum = sum(self.groupdegs)
            self.groupdegs.append(360-tmp_sum)
            
            for i, value in enumerate(self.groupdegs[: -1], 1):
                self.displays[self.enum_state.get(self.state)]["field"][i+2] = [f"диапазон {i}", self.set_range_not_equall, value]
            if self.groupdegs:
                self.motor.create_points()  
        # ..............................................................

        def start_head(self) -> None:
            self.state = 5
            self.substate = 1
            self.nav = 1
            self.lcd.clean()


        def stop_head(self) -> None:
                # удалить точки
            self.motor.delete_points()
                # очистить self.groupdegs
            self.groupdegs.clear()

            self.displays["PREPARE_NOT_AM"]["field"].clear()
                # state = BEGIN
            self.st_mtd_sett_yes()


        def cancel(self) -> None:
            self.substate = 0
            self.nav = 1
           

        def continue_head(self) -> None:
            if self.substate == 4:
                self.substate = 2

        # ................................................................

        def manual_mode(self) -> None:
            """После нажатия и удержания кнопки ручного режима.
               подмена метода вращения колеса мыши, если 'удерживается'.
               Вызывается в теле elif состояния PREPARE_AM"""

            if self.is_man_mode:
                    # запрет навигации. только больше-меньше значения параметра при вращении колеса мыши
                self.displays[self.enum_state.get(self.state)]["navigate"] = False
                self.wheel_method = self.rotate_val_man_mode
                self.lamp_man_mode.style = f"fill: rgb(0, 147, 49);"
                self.text_man_mode.textContent = "удержание кнопки"
            else:
                self.lamp_man_mode.style = f"fill: rgb(147, 22, 0);"
                self.text_man_mode.textContent = "не нажато"
                self.displays[self.enum_state.get(self.state)]["navigate"] = True
                self.wheel_method = self.st_mtd_wheel


        @substitute_wheel
        def set_range_not_equall(self) -> None:
            self.wheel_method = self.change_range_not_equall


        @substitute_wheel
        def set_dreductor(self) -> None:
            """поле ввода ПЕРЕДАТОЧН. ЧИСЛО РЕДУКТОРА.
            экран настройки. Событие по вращению колеса мыши"""
            
                # подменяю метод при вращении колеса мыши
            self.wheel_method = self.change_delta_reductor
                

        @substitute_wheel
        def set_amount(self) -> None:
            """поле ввода КОЛИЧЕСТВО равномерная разметка"""
            
                # подменяю метод при вращении колеса мыши
            self.wheel_method = self.count_field_equally


        @substitute_wheel
        def set_amount_not_eq(self) -> None:
            """поле ввода КОЛИЧЕСТВО не равномерная разметка"""

            self.wheel_method = self.count_field_not_equally
               

        @substitute_wheel
        def set_total_sum(self) -> None:
            """ поле ввода ГРАДУСЫ равномерная разметка"""

            # подменяю метод при вращении колеса мыши
            self.wheel_method = self.change_total_sum
               


        @substitute_wheel  
        def set_vauto(self) -> None:
            """поле ввода СКОРОСТЬ АВТО.
            экран настройки. Событие по нажатии"""

            self.wheel_method = self.change_vauto
           

        @substitute_wheel
        def set_vman(self) -> None:
            """поле ввода СКОРОСТЬ РУЧН.
            экран настройки. Событие по нажатии"""

            self.wheel_method = self.change_vman



        def st_mtd_wheel(self) -> None:
            """выделение пунктов в меню при вращении колеса мыши"""

                # в зависимости от направления вращения колеса мыши self.encoder.around_direction
                # то 1, то -1
              
            self.nav += self.encoder.around_direction
            
                # дисплей текущего состояния
            curr_display: dict = self.get_deploy_map_display()
                # количество пунктов для выделения
            len_nav = len(curr_display) 
            
                # выделение пунктов меню по кругу
            if (self.nav < 1):
                self.nav = len_nav
            elif (self.nav > len_nav):
                self.nav = 1
           
                 
        
        def get_nav(self, current_state: str) -> tuple:
            """возвращает строку меню с помеченным пунктом. 
               При каждом вызове формирует дисплей со строками. Возвращает кортеж 
               строку меню и список строк полей ввода. Формирование экрана дисплая текущего состояния."""
           
                # словарь вида {"nav":{1: ("да", self.st_mtd_sett_yes))}
            st_nav: dict = self.map_display[0]

                # словарь вида {"field":{2: (f"передат. число:", self.set_dreductor, self.delta_reductor), 3: (f"скорость авто:", self.set_vauto, self.vauto)}}
            field_nav: dict = self.map_display[1]
            
                # макс кол-во строк в дисплее включая навигационную 
            max_height_lines = self.lcd.maxlines
            

                # формирование строки меню с помеченным выбранным пунктом в зависимости от значения self.nav 
            navigate = list(map(lambda z: f"\u25b6{z[1][0]}\u25c0" if z[0] == self.nav else z[1][0], st_nav.items()))
                
                # формирование списка полей ввода с помеченным пунктом в зависимости от self.nav Работает в паре с строкой навигации
            field: list = list() 
           
                # если находимся в меню настроек при редактировании, то
                # мигаем значением редактируемого поля   
            for key, val in field_nav.items():
                if key == self.nav:                    
                    if not self.displays[current_state]["navigate"]:
                        if self.blink % 2 == 0:
                            result = f"\u25b6 {val[0]} {val[2]}"
                        else: 
                            result = f"\u25b6 {val[0]} "
                    else: result = f"\u25b6 {val[0]} {val[2]}"  
                else:
                    result = f"{val[0]} {val[2]}"
                field.append(result)
            
                # если длинна сформированного списка больше максимального числа
                # влезаемых в дисплей строк -- навигационную, то проверяем:
                # если мы на строке навигации, то возвращаем срез от начала списка, до макс. высоты дисплея-1
                # иначе возвращаем срез от тек.навигация - 3 (Заголовок - 1я, пробел - 2я. --3 т-к инд.списка с 0) до границ макс высоты дисплея
                # если состояние == PREPARE_NOT_AM то это вот все для него, остальные экраны не выходят содержимым за пределы
                # размеров дисплея, поэтому там все ок. В теле состояния очищаем дисплей,
                # т-к при прокрутке под конец остаются "не живые" строки.
            if len(field) >= self.lcd.maxlines - 2:
                if self.nav >= 3:
                    field = field[self.nav-3: self.nav+2]
                else:
                    field = field[:5]
                    
            return (f"{'\u00A0'*5}".join(navigate), field)



        def get_deploy_map_display(self) -> dict:
            """Может глупое название, но создает и 
               возвращает словарь из словарей (если существуют) тек. состояния.
               Нужно для определения счетчика выбора в меню. (чтобы знать кол-во пунктов для выбора)"""
            
            curr_display: dict = dict()

            for upd in self.map_display:
                if upd:
                    curr_display.update(upd)

            return curr_display



        def empty_method(self) -> None:
            """метод пустышка"""
            pass

        # - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        @property
        def this_param(self) -> Any:
            """Значение параметра в словаре в зависимости от тек. состояния """
            return self.displays[self.enum_state.get(self.state)]["field"][self.nav][2]

        @this_param.setter
        def this_param(self, value: Any) -> None:
            self.displays[self.enum_state.get(self.state)]["field"][self.nav][2] = value



        @property
        def state(self) -> int:
            return self._state

        @state.setter
        def state(self, value: int) -> None:
            self._state = value



        @property
        def substate(self) -> int:
            return self._substate

        @substate.setter
        def substate(self, value: int) -> None:
            self._substate = value

        
        @property
        def amount(self) -> int:
            """Количество. Равномерная разметка."""
            return self.displays["EQUALLY"]["field"][2][2]

        @amount.setter
        def amount(self, value: int) -> None:
            if self.amount > 360:
                self.this_param -= 1
            elif self.amount <= 0:
                self.this_param = 1
            else:
                self.this_param = int(value)
                try:
                    self.displays["EQUALLY"]["field"][3][2] = round(360 / self.amount, 2)
                except ZeroDivisionError:
                    self.displays["EQUALLY"]["field"][3][2] = 360
            self._amount = self.amount
        
            
        @property
        def amount_not_eq(self) -> int:
            """Количество меток. Не равномерная разметка."""
            return self.displays["NOT_EQUALLY"]["field"][2][2]


        @amount_not_eq.setter
        def amount_not_eq(self, value: int) -> None:
            if self.amount_not_eq > 360:
                self.this_param = 0
            elif self.amount <= 0:
                self.this_param = 1
            else:
                self.this_param = int(value)


        @property
        def total_sum(self) -> int:
            """Сумма разбиений при равномерной разметке"""
            return self.displays["EQUALLY"]["field"][3][2]


        @total_sum.setter
        def total_sum(self, value: float) -> None:
            if value >= 1:
                self.this_param = value
            
            if (self.total_sum * self.amount) > 360:
                while self.total_sum * self.amount > 360:
                    self.this_param -= 1
            


        @property
        def delta_reductor(self) -> float:
            """Передаточное число редуктора"""
            return self.displays["SETTING"]["field"][2][2]

        @delta_reductor.setter
        def delta_reductor(self, value: float) -> None:
            self.this_param = 1 if self.delta_reductor <= 0 else float(value)
            try:
                x = 1 / self.delta_reductor
            except ZeroDivisionError:
                self.this_param = 0.5   
        
        @property
        def vauto(self) -> float:
            """SETTING скорость в авто режиме"""
            return self.displays["SETTING"]["field"][3][2]

        @vauto.setter
        def vauto(self, value: float) -> None:
            self.this_param = 0.1 if self.vauto <= 0 else round(value, 2)
            try:
                x = 1 / self.vauto
            except ZeroDivisionError:
                self.this_param = 0.1

        @property
        def vman(self) -> float:
            return self.displays["SETTING"]["field"][4][2]

        @vman.setter
        def vman(self, value: int) -> None:
            self.this_param = 1 if self.vman <= 0 else value
            try:
                x = 1 / self.vman
            except ZeroDivisionError:
                self.this_param = 1   


        @property
        def nav(self) -> int:
            return self._nav

        @nav.setter
        def nav(self, value: int) -> None:
            self._nav = value

        
        @property
        def degpos(self) -> float:
            """Текущий угол поворота вала"""
            return self._deg_pos

        @degpos.setter
        def degpos(self, value: float) -> None:
            self._deg_pos = value if type(value) is float else float(value) 


        @property
        def nextpoint(self) -> float:
            """Следующее значение градусов в списке self.groupdegs"""
            return self._next_point

        @nextpoint.setter
        def nextpoint(self, value: float) -> None:
            self._next_point = value if type(value) is float else round(float(value), 3)


        @property
        def motor(self) -> Motor:
            return self._motor

        @motor.setter   
        @inject
        def motor(self, obj) -> None:
            self._motor = obj
           
            

        @property
        def encoder(self) -> Encoder:
            return self._encoder

        @encoder.setter
        @inject
        def encoder(self, obj) -> None:
            self._encoder = obj



        @property
        def lcd(self) -> Lcd:
            return self._lcd

        @lcd.setter
        @inject
        def lcd(self, obj) -> None:
            self._lcd = obj

        

        def button_wheel(self) -> None:
            """Вызов по нажатии колеса мыши."""
            pass


        def round_wheel(self) -> None:
            """Вызов когда крутят енкодер + крутим мотор с передаточным числом"""
            
            self.lcd.write(f"___________{self.encoder.total_deg}", 3)
            self.motor.degstep = (self.encoder.deg_step * self.encoder.around_direction) / self.delta_reductor

        
    # ------------------------------- main --------------------------------------------------------------------
    
    lcd_display = Lcd("lcd", 12)
    man_encoder = Encoder("encoder", "encoder-svg")
    motor = Motor("val", "limb")
    controller = ATMega(lcd_display, man_encoder, motor)
    controller.run()

            # disabled
    @bind(document["power-on"], "click")
    def start_rotate(e):
        controller.lcd.on_power()
     
            # disabled
    @bind(document["power-off"], "click")
    def stop_rotate(e):
        controller.motor.degstep = 10

           
    @bind(document["man-mode"], "click")
    def man_mode(e):
        b = controller.is_man_mode 
        controller.is_man_mode = not b
    
    </script>
      
    </body>
    </html>                  